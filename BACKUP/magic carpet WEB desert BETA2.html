<!DOCTYPE html>
<html>
<head>
<title>Refactored Psy Flight N+-1 (v3.8: Desert Fire)</title> <!-- Title updated -->
<meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Added for mobile -->
<style>
    body { margin: 0; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
    canvas { background-color: #050510; border: 2px solid #445; cursor: pointer; max-width: 100%; max-height: 100%; object-fit: contain; image-rendering: pixelated; /* Optional: sharper pixels */ }
    #message { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: #9ef; background-color: rgba(0,10,20,0.7); padding: 5px 10px; border-radius: 5px; font-size: 24px; font-family: sans-serif; text-align: center; display: none; z-index: 10; text-shadow: 1px 1px 2px #000; }
    #instructions { position: absolute; bottom: 10px; left: 10px; color: #bbb; font-size: 12px; font-family: sans-serif; text-shadow: 1px 1px 2px #000; z-index: 5;} /* Make sure instructions are visible */
    #audioOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); color: white; font-size: 30px; font-family: sans-serif; display: flex; justify-content: center; align-items: center; text-align: center; cursor: pointer; z-index: 20; }
    #timer { position: absolute; top: 10px; right: 15px; color: #eee; font-size: 20px; font-family: monospace; text-shadow: 1px 1px 2px #000; z-index: 5; }
    #livesDisplay { position: absolute; top: 35px; right: 15px; color: #f99; font-size: 18px; font-family: monospace; text-shadow: 1px 1px 2px #000; z-index: 5; transition: color 0.1s ease-out, text-shadow 0.1s ease-out; }
    #orbShieldDisplay { position: absolute; top: 55px; right: 15px; color: #9cf; font-size: 16px; font-family: monospace; text-shadow: 1px 1px 2px #000; z-index: 5; transition: color 0.1s ease-out, text-shadow 0.1s ease-out; }
    /* Simple Touch Buttons - Adjust styling as needed */
    #touchButtons { position: absolute; bottom: 30px; left: 10px; right: 10px; height: 100px; display: flex; justify-content: space-between; z-index: 15; pointer-events: none; /* Allow clicks through initially */ }
    .touchButton { background-color: rgba(200, 200, 200, 0.3); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; width: 70px; height: 70px; display: flex; justify-content: center; align-items: center; color: white; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 1px black; pointer-events: auto; /* Enable pointer events for buttons */ user-select: none; /* Prevent text selection */ -webkit-user-select: none; }
    #touchLeft { position: absolute; left: 20px; bottom: 0; }
    #touchRight { position: absolute; left: 110px; bottom: 0; }
    #touchJump { position: absolute; right: 110px; bottom: 0; background-color: rgba(173, 216, 230, 0.4); } /* Lightblue */
    #touchAttack { position: absolute; right: 20px; bottom: 80px; width: 60px; height: 60px; background-color: rgba(255, 100, 100, 0.4); } /* Reddish */
    #touchShoot { position: absolute; right: 20px; bottom: 0px; width: 60px; height: 60px; background-color: rgba(255, 165, 0, 0.4); } /* Orangey */

</style>
</head>
<body>

<div id="audioOverlay">Click or Tap<br>to Start Audio & Game</div>
<div id="message"></div>
<div id="instructions">Arrows/AD: Move | W/Up/Space/Btn: Fly/Jump | X/Btn: Attack | F/Btn: Fireball | R: New Level/Next | M: Mute</div>
<div id="timer">0.00</div>
<div id="livesDisplay">Lives: 3</div>
<div id="orbShieldDisplay">Shield: 0</div>

<!-- Touch Control Buttons -->
<div id="touchButtons" style="display: none;"> <!-- Initially hidden -->
    <div id="touchLeft" class="touchButton">â—€</div>
    <div id="touchRight" class="touchButton">â–¶</div>
    <div id="touchJump" class="touchButton">â–²</div>
    <div id="touchAttack" class="touchButton">âš”</div>
    <div id="touchShoot" class="touchButton">ðŸ”¥</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageDiv = document.getElementById('message');
    const audioOverlay = document.getElementById('audioOverlay');
    const timerDiv = document.getElementById('timer');
    const livesDisplayDiv = document.getElementById('livesDisplay');
    const orbShieldDisplayDiv = document.getElementById('orbShieldDisplay');
    const touchButtonContainer = document.getElementById('touchButtons'); // Get touch button container

    // --- Constants ---
    // ... (Keep all existing constants) ...
    const MAX_DELTA_TIME = 0.05; // Prevents physics glitches on lag spikes

    // --- Initial Game Object States ---
    const player = { x: 100, y: canvas.height - 100, width: 20, height: 45, velocityX: 0, velocityY: 0, onGround: false, groundPlatform: null, facingDirection: 'right', animationState: 'idle', animationTimer: 0, animationFrameIndex: 0, isAttattacking: false, attackTimer: 0, attackCooldownTimer: 0, landingTimer: 0, coyoteTimer: 0, lives: STARTING_LIVES, orbShieldCount: 0, fireballCooldownTimer: 0 };
    const goal = { x: 0, y: 0, width: GOAL_DOOR_WIDTH, height: GOAL_DOOR_HEIGHT, color: GOAL_FRAME_COLOR };
    const batProto = { x: 0, y: 0, width: 25, height: 15, velocityX: 0, velocityY: 0, type: 'bat', state: 'idle', stateTimer: 0, originX: 0, originY: 0, patrolTargetX: 0, patrolTargetY: 0, patrolRange: BAT_PATROL_RANGE, detectionRadius: BAT_DETECTION_RADIUS, leashRadius: BAT_LEASH_RADIUS, chaseSpeed: 80.0, patrolSpeed: 48.0, flapTimer: 0, health: 1, randomMoveTimer: 0 };
    const groundPatrollerProto = { x: 0, y: 0, width: PATROLLER_WIDTH, height: PATROLLER_HEIGHT, velocityX: 0, /* Start stationary */ type: 'patroller', health: PATROLLER_HEALTH, onPlatform: null, direction: 1 }; // Initialize velocityX to 0
    const fireballProto = { x: 0, y: 0, vx: 0, vy: 0, radius: FIREBALL_RADIUS, life: FIREBALL_LIFESPAN, active: false };

    // --- Utility Functions ---
    // ... (Keep all existing utility functions) ...
    function clamp(value, min, max) { return Math.max(min, Math.min(max, value)); } // Added clamp function

    // --- Stick Figure Definition ---
    // ... (Keep stick figure definition) ...

    // --- Audio Functions ---
    // ... (Keep all audio functions, including try/catch blocks) ...

    // --- Particle Pool Class ---
    // ... (Keep ParticlePool class) ...

    // --- Effects System ---
    // ... (Keep createEffectsSystem function) ...

    // --- Touch Controls Class (Revised) ---
    class TouchControls {
        constructor(gameInstance) {
            this.game = gameInstance;
            this.touchState = { left: false, right: false, jump: false, attack: false, shoot: false };
            this.activeTouches = {}; // Store touch identifier -> zone mapping

            this.elements = {
                container: document.getElementById('touchButtons'),
                left: document.getElementById('touchLeft'),
                right: document.getElementById('touchRight'),
                jump: document.getElementById('touchJump'),
                attack: document.getElementById('touchAttack'),
                shoot: document.getElementById('touchShoot'),
            };

            this.addListeners();
            this.show(); // Show buttons immediately if touch is likely
        }

        addListeners() {
            // Use the container for more robust event handling on mobile
            const targetElement = this.elements.container.parentElement; // Usually body or a main game container

            targetElement.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
            targetElement.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
            targetElement.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
            targetElement.addEventListener('touchcancel', this.handleTouchEnd.bind(this), { passive: false });

            // Individual button listeners (optional, but can handle direct taps better)
            Object.entries(this.elements).forEach(([key, element]) => {
                if (key === 'container' || !element) return;
                 element.addEventListener('touchstart', (e) => { e.preventDefault(); this.touchState[key] = true; this.updateButtonVisuals(); }, { passive: false });
                 element.addEventListener('touchend', (e) => { e.preventDefault(); this.touchState[key] = false; this.updateButtonVisuals(); }, { passive: false });
                 element.addEventListener('touchcancel', (e) => { e.preventDefault(); this.touchState[key] = false; this.updateButtonVisuals(); }, { passive: false });
            });
        }

        // Simplified Start/Move/End for basic button state
        handleTouchStart(event) {
            event.preventDefault();
            this.processTouches(event.changedTouches);
        }

        handleTouchMove(event) {
            event.preventDefault();
             // If needed for dragging controls in the future, process here
             // For simple buttons, move doesn't change the state if the touch *started* on the button
        }

        handleTouchEnd(event) {
            event.preventDefault();
             // Reset states for lifted touches
             for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const zone = this.activeTouches[touch.identifier];
                if (zone && this.touchState[zone]) {
                    this.touchState[zone] = false;
                }
                delete this.activeTouches[touch.identifier];
            }
            this.updateButtonVisuals();
        }

        processTouches(touches) {
             for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const touchX = touch.clientX; // Use clientX/Y for simplicity
                const touchY = touch.clientY;

                // Check which button the touch is over
                for (const [zone, element] of Object.entries(this.elements)) {
                    if (zone === 'container' || !element) continue;
                    const rect = element.getBoundingClientRect();
                    if (touchX >= rect.left && touchX <= rect.right &&
                        touchY >= rect.top && touchY <= rect.bottom)
                    {
                        this.touchState[zone] = true;
                        this.activeTouches[touch.identifier] = zone; // Track which touch is activating which zone
                        break; // A touch can only activate one button
                    }
                }
            }
            this.updateButtonVisuals();
        }


        updateButtonVisuals() {
            for (const [zone, element] of Object.entries(this.elements)) {
                 if (zone === 'container' || !element) continue;
                 if (this.touchState[zone]) {
                     element.style.transform = 'scale(0.9)';
                     element.style.opacity = '0.8';
                 } else {
                     element.style.transform = 'scale(1.0)';
                     element.style.opacity = '1.0'; // Reset opacity or keep base style
                 }
             }
        }


        getInput() {
            // Directly return the state
            return {
                left: this.touchState.left,
                right: this.touchState.right,
                space: this.touchState.jump, // Map jump to space
                attack: this.touchState.attack,
                shoot: this.touchState.shoot, // Add shoot state
            };
        }

        // No render needed, buttons are HTML elements

        show() { if (this.elements.container) this.elements.container.style.display = 'flex'; }
        hide() { if (this.elements.container) this.elements.container.style.display = 'none'; }
    }


    // --- Level Generator Class ---
    // ... (Keep LevelGenerator class) ...
    // Minor tweak: Ensure ground patrollers don't overlap vertically excessively if platforms are close
    // In generateLevel, inside the ground patroller placement check:
    // Add after `if (!tooClose)`:
    /*
       for (const plat of platforms) {
           if (plat !== newPlat && checkRectOverlap({x: patroller.x - 5, y: patroller.y - 5, width: patroller.width + 10, height: patroller.height + 10}, plat)) {
               tooClose = true; // Prevent spawning inside another platform visually
               console.warn("Patroller placement skipped due to potential platform overlap.");
               break;
           }
       }
       if (!tooClose) {
          groundPatrollers.push(patroller);
       }
    */ // This check might be overly cautious, review if it prevents too many spawns.

    // --- Save System Class ---
    // ... (Keep SaveSystem class) ...

    // --- PowerUp System Class (Placeholder) ---
    // ... (Keep PowerUpSystem class) ...

    // --- Scene Base Class ---
    // ... (Keep Scene class) ...

    // --- Gameplay Scene ---
    class GameplayScene extends Scene {
        constructor() {
            super();
            this.player = { ...player }; // Creates a shallow copy
            this.platforms = [];
            this.collectibles = [];
            this.bats = [];
            this.groundPatrollers = [];
            this.goal = { ...goal }; // Shallow copy
            this.stars = [];
            this.fireballs = [];
            this.orbiterAngle = 0;
            this.levelEndX = 0;
            this.gameWon = false;
            this.gameStartTime = null;
            this.lastFrameTime = 0;
            this.levelNumber = 1;
            this.messageTimeoutId = null;
            this.startPlatform = null;
            this.levelGenerator = null;
            this.effectsSystem = null;
            this.powerUpSystem = null;
            this.screenFlashTimer = 0;
            this.screenFlashColor = null;
        }

        onEnter() {
            console.log("Entering Gameplay Scene...");
            try {
                this.levelNumber = this.game.saveSystem.data.currentLevel || 1;
                this.levelGenerator = new LevelGenerator(canvas.width, canvas.height);
                this.effectsSystem = createEffectsSystem();
                this.powerUpSystem = new PowerUpSystem(this.player);
                this.generateLevel(); // Generate first level
                this.gameStartTime = performance.now();
                this.lastFrameTime = this.gameStartTime;
                this.gameWon = false;
                messageDiv.style.display = 'none';
                if (this.messageTimeoutId) clearTimeout(this.messageTimeoutId);
                this.initStars();
                this.screenFlashTimer = 0;
                this.screenFlashColor = null;
                if (this.game.isAudioInitialized && this.game.musicIntervalId === null && !this.game.isMuted) {
                    this.game.startMusic();
                }
                 if (this.game.isTouchDevice) { // Show touch controls if needed
                     this.game.touchControls?.show();
                 } else {
                     this.game.touchControls?.hide();
                 }
                console.log("Gameplay Scene onEnter finished successfully.");
            } catch (error) {
                console.error("CRITICAL ERROR during GameplayScene onEnter:", error);
                alert("A critical error occurred loading the level. Check the console.");
                if(this.game) this.game.stop();
            }
         }

        onExit() {
            if (this.messageTimeoutId) clearTimeout(this.messageTimeoutId);
             if (this.game.isTouchDevice) { // Hide touch controls when leaving scene
                 this.game.touchControls?.hide();
             }
        }

        generateLevel() {
             console.log(`GameplayScene.generateLevel called for level ${this.levelNumber}.`);
             try {
                 const levelData = this.levelGenerator.generateLevel();
                 if (!levelData || !levelData.startPlatform || !levelData.collectibles || !levelData.goal || !levelData.bats || !levelData.groundPatrollers) {
                     throw new Error("Level generator failed to return valid data.");
                 }
                 this.platforms = levelData.platforms;
                 this.goal = levelData.goal;
                 this.collectibles = levelData.collectibles.map(c => ({...c, collected: false})); // Ensure collectibles are reset
                 this.bats = levelData.bats.map(b => ({...b})); // Create copies of bat data
                 this.groundPatrollers = levelData.groundPatrollers.map(p => ({...p})); // Create copies
                 this.levelEndX = levelData.levelEndX;
                 this.startPlatform = levelData.startPlatform;

                 // Reset Player State Fully
                 this.player = {
                     ...player, // Start from base defaults
                     x: this.startPlatform.x + this.startPlatform.width / 2 - player.width / 2,
                     y: this.startPlatform.y - player.height - 1,
                     lives: this.player.lives > 0 ? this.player.lives : STARTING_LIVES, // Keep lives if > 0, else reset
                     orbShieldCount: 0, // Reset shield on new level
                 };

                 // Reset other necessary scene states
                 this.gameWon = false;
                 this.orbiterAngle = 0;
                 this.screenFlashTimer = 0;
                 this.screenFlashColor = null;
                 this.fireballs = []; // Clear existing fireballs

                 this.updateLivesDisplay();
                 this.updateOrbShieldDisplay();
                 console.log(`Level generated. Player Spawn: (${this.player.x.toFixed(0)}, ${this.player.y.toFixed(0)}). Lives: ${this.player.lives}, Shield: ${this.player.orbShieldCount}`);

             } catch (error) {
                 console.error("CRITICAL ERROR within GameplayScene.generateLevel:", error);
                 alert("Failed to generate the level layout. Please try refreshing.");
                 if(this.game) this.game.stop();
             }
         }

        initStars() { /* ... (keep) ... */ }

        update(deltaTime) {
            if (this.gameWon) return;
            if (this.screenFlashTimer > 0) { this.screenFlashTimer -= deltaTime; }

            const kbdInput = this.game.inputState.keys;
            const touchInput = this.game.touchControls ? this.game.touchControls.getInput() : { left: false, right: false, space: false, attack: false, shoot: false }; // Include shoot

            // Combine Inputs
            const combinedInput = {
                left: kbdInput.left || touchInput.left,
                right: kbdInput.right || touchInput.right,
                jumpOrFly: kbdInput.space || kbdInput.up || kbdInput.w || touchInput.space,
                attack: kbdInput.x || touchInput.attack,
                shoot: kbdInput.f || touchInput.shoot // Combine keyboard 'f' and touch shoot
            };

            this.updatePlayer(deltaTime, combinedInput);
            this.updateBats(deltaTime);
            this.updateGroundPatrollers(deltaTime);
            this.updateFireballs(deltaTime);
            if (this.player.isAttacking) { // Note: Property name might be isAttacking (typo in original?)
                this.checkAttackCollisions();
            }
            this.effectsSystem.update(deltaTime);
            this.powerUpSystem.update(deltaTime);
            this.updateOrbiter(deltaTime);
            this.checkCollisions();
            this.checkBoundaries();
        }

        updatePlayer(dt, input) {
            // --- Timers ---
            if (this.player.attackCooldownTimer > 0) this.player.attackCooldownTimer -= dt;
            if (this.player.attackTimer > 0) this.player.attackTimer -= dt; else this.player.isAttacking = false; // Ensure attack stops
            if (this.player.landingTimer > 0) this.player.landingTimer -= dt;
            if (this.player.coyoteTimer > 0) this.player.coyoteTimer -= dt;
            if (this.player.fireballCooldownTimer > 0) this.player.fireballCooldownTimer -= dt;

            // --- Attack State ---
            // Check consistency: isAttacking vs isAttattacking
            const isAttackingProperty = 'isAttattacking' in this.player ? 'isAttattacking' : 'isAttacking'; // Handle potential typo
            if (input.attack && !this.player[isAttackingProperty] && this.player.attackCooldownTimer <= 0) {
                this.player[isAttackingProperty] = true;
                this.player.attackTimer = ATTACK_DURATION;
                this.player.attackCooldownTimer = ATTACK_DURATION + ATTACK_COOLDOWN;
                if (game && game.audioCtx) triggerSwordSwing(game.audioCtx.currentTime);
            }
             if (this.player.attackTimer <= 0) {
                this.player[isAttackingProperty] = false;
            }


            // --- Fireball Shooting ---
            if (input.shoot && this.player.fireballCooldownTimer <= 0) {
                // Determine target based on input type
                let targetX, targetY;
                if (this.game.lastInputType === 'touch' || !this.game.hasMouseMoved) {
                    // Touch input or no mouse movement: Fire straight ahead
                    const playerCenterX = this.player.x + this.player.width / 2;
                    const playerCenterY = this.player.y + this.player.height / 2;
                    targetX = playerCenterX + (this.player.facingDirection === 'right' ? 100 : -100); // Fire 100px ahead
                    targetY = playerCenterY; // Fire horizontally
                } else {
                    // Mouse input: Fire towards mouse cursor
                    const cameraX = clamp(this.player.x - canvas.width / 3, 0, this.levelEndX - canvas.width);
                    targetX = this.game.mouseX + cameraX;
                    targetY = this.game.mouseY;
                }
                this.spawnFireball(targetX, targetY); // Pass target to spawn function
            }


            const wasOnGround = this.player.onGround;

            // --- Horizontal Movement ---
            let targetVelX = this.player.velocityX;
            const currentAccel = this.player.onGround ? GROUND_ACCELERATION : AIR_ACCELERATION;
            const currentMaxSpeed = this.player.onGround ? GROUND_MAX_SPEED : AIR_MAX_SPEED;
            const currentFriction = this.player.onGround ? GROUND_FRICTION : AIR_FRICTION;
            // Apply less acceleration if attacking
            const effectiveAccel = this.player[isAttackingProperty] ? currentAccel * 0.3 : currentAccel;

            if (input.left) { targetVelX -= effectiveAccel; if (!this.player[isAttackingProperty]) this.player.facingDirection = 'left'; }
            else if (input.right) { targetVelX += effectiveAccel; if (!this.player[isAttackingProperty]) this.player.facingDirection = 'right'; }
            else { targetVelX *= currentFriction; }
            this.player.velocityX = clamp(targetVelX, -currentMaxSpeed, currentMaxSpeed); // Use clamp
            if (Math.abs(this.player.velocityX) < 0.1) this.player.velocityX = 0;

            // --- Vertical Movement (Gravity) ---
            const holdingFlyInAir = input.jumpOrFly && !this.player.onGround && !this.player[isAttackingProperty];
            const currentGravity = holdingFlyInAir ? gravity * FLYING_GRAVITY_MULTIPLIER : gravity;
            this.player.velocityY += currentGravity;

            // --- Jumping & Flying ---
            const canJump = this.player.onGround || this.player.coyoteTimer > 0;
            if (input.jumpOrFly && !this.player[isAttackingProperty]) {
                 if (canJump) {
                     this.player.velocityY = -JUMP_STRENGTH;
                     this.player.coyoteTimer = 0;
                     this.player.onGround = false;
                     this.player.groundPlatform = null; // Ensure ground platform is cleared on jump
                     if (game && game.audioCtx) triggerJumpSound(game.audioCtx.currentTime);
                 } else if (!this.player.onGround) { // Apply fly strength only if already in air
                     this.player.velocityY -= FLY_STRENGTH;
                     this.player.velocityY = Math.max(-MAX_FLY_SPEED, this.player.velocityY);
                 }
            }

            // --- Platform Collision (Vertical) ---
            // Store original state before prediction
            const originalY = this.player.y;
            const originalVelY = this.player.velocityY;
            const potentialY = this.player.y + this.player.velocityY * dt;
            let landedOnPlatform = null;
            let hitCeiling = false;

            this.player.onGround = false; // Assume not on ground initially for this frame

            for (const platform of this.platforms) {
                const playerRect = { x: this.player.x, y: potentialY, width: this.player.width, height: this.player.height };
                const platformRect = { x: platform.x, y: platform.y, width: platform.width, height: platform.height };

                // Check horizontal overlap first for efficiency
                if (playerRect.x + playerRect.width > platformRect.x && playerRect.x < platformRect.x + platformRect.width) {
                    // Check for landing (moving down, was above, will be below or intersecting)
                    if (originalVelY >= 0 && originalY + this.player.height <= platformRect.y + 1 && potentialY + this.player.height >= platformRect.y) {
                        this.player.y = platformRect.y - this.player.height;
                        this.player.velocityY = 0;
                        this.player.onGround = true; // Landed
                        landedOnPlatform = platform;
                        this.player.coyoteTimer = 0; // Reset coyote timer on landing
                        if (!wasOnGround) { // Trigger landing effects only if newly landed
                            this.player.landingTimer = 0.15;
                            if (game && game.audioCtx) triggerLandSound(game.audioCtx.currentTime);
                        }
                        // Break checking platforms once landed, prevents multi-platform issues in one frame
                         break;
                    }
                    // Check for hitting ceiling (moving up, was below, will be above or intersecting)
                    if (originalVelY < 0 && originalY >= platformRect.y + platformRect.height - 1 && potentialY <= platformRect.y + platformRect.height) {
                        this.player.y = platformRect.y + platformRect.height;
                        this.player.velocityY = 0; // Stop upward movement
                        hitCeiling = true;
                         // Don't break here, might still land on another platform later in the frame if falling fast
                    }
                }
            }

             // Update ground platform reference *after* checking all platforms
             this.player.groundPlatform = landedOnPlatform;


            // --- Coyote Timer Activation ---
            // Activate if was on ground last frame but is not this frame (and didn't just jump)
            if (wasOnGround && !this.player.onGround && originalVelY >= 0) { // Check velY to ensure not during ascent of jump
                 this.player.coyoteTimer = COYOTE_TIME_DURATION;
             }


            // --- Update Position ---
            // Apply horizontal velocity
            this.player.x += this.player.velocityX * dt;

            // Apply vertical velocity ONLY IF not landed on a platform in this frame's check
            // The vertical position was already adjusted during collision checks if a collision occurred
            if (!this.player.onGround) {
                this.player.y += this.player.velocityY * dt;
            }


            // --- Animation State Logic ---
            let newState = 'idle';
            if (this.player[isAttackingProperty]) newState = 'attacking';
            else if (this.player.landingTimer > 0) newState = 'landing';
            // Use coyoteTimer condition for jumping state accurately
            else if (!this.player.onGround && this.player.coyoteTimer <= 0) newState = 'jumping';
            else if (this.player.onGround && Math.abs(this.player.velocityX) > 0.1) newState = 'running';
            else if (this.player.onGround) newState = 'idle';

            if (this.player.animationState !== newState) {
                this.player.animationState = newState;
                this.player.animationTimer = 0;
                this.player.animationFrameIndex = 0;
            }

            // --- Animation Frame Update ---
            const animSpeedNorm = this.player.onGround ? GROUND_MAX_SPEED : AIR_MAX_SPEED;
            const effectiveAnimSpeed = animationSpeed * (newState === 'running' ? Math.max(0.3, Math.abs(this.player.velocityX / animSpeedNorm)) : 1); // Add base speed to running anim
            this.player.animationTimer += dt * effectiveAnimSpeed;
            const currentPoseArray = stickFigure.poses[this.player.animationState];
            if (currentPoseArray && currentPoseArray.length > 0) {
                this.player.animationFrameIndex = Math.floor(this.player.animationTimer) % currentPoseArray.length;
            } else {
                this.player.animationFrameIndex = 0;
                // Only warn if it's not idle and missing
                 if (this.player.animationState !== 'idle' && !stickFigure.poses[this.player.animationState]) {
                     console.warn("Missing pose definition for state:", this.player.animationState);
                 }
            }

            // --- Player Stardust Trail Emission ---
            const emitStardust = (holdingFlyInAir && Math.random() < STARDUST_EMIT_RATE * 1.5) ||
                                 (!this.player.onGround && Math.abs(this.player.velocityY) > gravity * 5 && Math.random() < STARDUST_EMIT_RATE) ||
                                 (this.player.onGround && Math.abs(this.player.velocityX) > GROUND_MAX_SPEED * 0.5 && Math.random() < STARDUST_EMIT_RATE * 0.5); // Less when running
            if (emitStardust) {
                const trailX = this.player.x + this.player.width / 2;
                const trailY = this.player.y + this.player.height; // Emit from feet
                this.effectsSystem.emitPlayerTrail(trailX, trailY, this.player.velocityX, this.player.velocityY);
            }
         } // End updatePlayer

         updateBats(deltaTime) {
             const BAT_ACCELERATION = 500; // How quickly the bat changes direction
             const BAT_FRICTION = 0.9; // Slows down the bat gradually
             const BAT_PLATFORM_PUSH_FORCE = 2.5; // How strongly bats push off platforms

             this.bats.forEach(bat => {
                 if (bat.health <= 0) {
                     // Ensure dead bats are truly out of the way
                     if(bat.y > -500) {
                         bat.x = -1000;
                         bat.y = -1000;
                         bat.velocityX = 0;
                         bat.velocityY = 0;
                     }
                     return;
                 }

                 bat.flapTimer += deltaTime * 15; // Keep flapping animation
                 if (bat.stateTimer > 0) bat.stateTimer -= deltaTime; // Only decrement if positive

                 const playerCenterX = this.player.x + this.player.width / 2;
                 const playerCenterY = this.player.y + this.player.height / 2;
                 const batCenterX = bat.x + bat.width / 2;
                 const batCenterY = bat.y + bat.height / 2;

                 const dxPlayer = playerCenterX - batCenterX;
                 const dyPlayer = playerCenterY - batCenterY;
                 const distSqPlayer = dxPlayer * dxPlayer + dyPlayer * dyPlayer;

                 const dxOrigin = bat.originX - batCenterX;
                 const dyOrigin = bat.originY - batCenterY;
                 const distSqOrigin = dxOrigin * dxOrigin + dyOrigin * dyOrigin;

                 // --- State Transitions ---
                 if (bat.state === 'chasing') {
                     if (distSqPlayer > bat.leashRadius * bat.leashRadius) {
                         bat.state = 'returning';
                         bat.stateTimer = 10; // Time limit to return
                     }
                 } else if (bat.state === 'returning') {
                     if (distSqOrigin < BAT_ORIGIN_THRESHOLD_SQ || bat.stateTimer <= 0) {
                         bat.state = 'patrolling';
                         [bat.patrolTargetX, bat.patrolTargetY] = getRandomPatrolPoint(bat.originX, bat.originY, bat.patrolRange);
                         bat.stateTimer = getRandom(3, 6);
                     }
                 } else { // Idle or Patrolling
                     if (distSqPlayer < bat.detectionRadius * bat.detectionRadius) {
                         bat.state = 'chasing';
                         bat.stateTimer = 0; // No timer for chasing
                     } else if (bat.state === 'patrolling' && bat.stateTimer <= 0) {
                         [bat.patrolTargetX, bat.patrolTargetY] = getRandomPatrolPoint(bat.originX, bat.originY, bat.patrolRange);
                         bat.stateTimer = getRandom(3, 6);
                     } else if (bat.state === 'idle' && bat.stateTimer <= 0) {
                         bat.state = 'patrolling';
                         [bat.patrolTargetX, bat.patrolTargetY] = getRandomPatrolPoint(bat.originX, bat.originY, bat.patrolRange);
                         bat.stateTimer = getRandom(3, 6);
                     }
                 }

                 // --- Movement Logic ---
                 let targetX, targetY, maxSpeed, acceleration;

                 if (bat.state === 'chasing') {
                     targetX = playerCenterX;
                     targetY = playerCenterY;
                     maxSpeed = bat.chaseSpeed; // Speeds are now pixels/sec
                     acceleration = BAT_ACCELERATION * 1.2;
                 } else if (bat.state === 'returning') {
                     targetX = bat.originX;
                     targetY = bat.originY;
                     maxSpeed = bat.patrolSpeed * BAT_RETURN_SPEED_MULTIPLIER;
                     acceleration = BAT_ACCELERATION * 1.1;
                 } else { // Patrolling or Idle (moves towards patrol target)
                     targetX = bat.patrolTargetX;
                     targetY = bat.patrolTargetY;
                     maxSpeed = bat.patrolSpeed;
                     acceleration = BAT_ACCELERATION;
                 }

                 // Calculate direction towards target
                 const dxTarget = targetX - batCenterX;
                 const dyTarget = targetY - batCenterY;
                 const distTarget = Math.sqrt(dxTarget * dxTarget + dyTarget * dyTarget);

                 // Apply acceleration towards target
                 if (distTarget > 1) { // Avoid division by zero and jittering
                     const accelFactor = acceleration / distTarget;
                     bat.velocityX += dxTarget * accelFactor * deltaTime;
                     bat.velocityY += dyTarget * accelFactor * deltaTime;
                 }

                 // Apply friction (using exponential decay based on frame time)
                 const frictionFactor = Math.pow(BAT_FRICTION, deltaTime * 60); // Adjust friction based on 60fps baseline
                 bat.velocityX *= frictionFactor;
                 bat.velocityY *= frictionFactor;

                 // Clamp speed
                 const currentSpeedSq = bat.velocityX * bat.velocityX + bat.velocityY * bat.velocityY;
                 const maxSpeedSq = maxSpeed * maxSpeed;
                 if (currentSpeedSq > maxSpeedSq) {
                     const speedScale = Math.sqrt(maxSpeedSq / currentSpeedSq);
                     bat.velocityX *= speedScale;
                     bat.velocityY *= speedScale;
                 }

                 // Store potential next position
                 let nextX = bat.x + bat.velocityX * deltaTime;
                 let nextY = bat.y + bat.velocityY * deltaTime;
                 let pushedX = 0;
                 let pushedY = 0;

                 // Simple collision avoidance with platforms (push away)
                 for (const platform of this.platforms) {
                     const batRectNext = { x: nextX, y: nextY, width: bat.width, height: bat.height };
                     if (checkRectOverlap(batRectNext, platform)) {
                         // Calculate overlap amounts
                         const overlapX = (batCenterX + bat.velocityX * deltaTime) - (platform.x + platform.width / 2);
                         const overlapY = (batCenterY + bat.velocityY * deltaTime) - (platform.y + platform.height / 2);
                         const combinedHalfWidth = (bat.width + platform.width) / 2;
                         const combinedHalfHeight = (bat.height + platform.height) / 2;
                         const overlapAmountX = combinedHalfWidth - Math.abs(overlapX);
                         const overlapAmountY = combinedHalfHeight - Math.abs(overlapY);

                         if (overlapAmountX > 0 && overlapAmountY > 0) {
                              // Resolve collision based on the shallower overlap axis
                             if (overlapAmountX < overlapAmountY) {
                                 const pushDirX = Math.sign(overlapX);
                                 pushedX += pushDirX * overlapAmountX * BAT_PLATFORM_PUSH_FORCE * deltaTime; // Apply push scaled by dt
                                 bat.velocityX *= 0.5; // Dampen velocity on collision
                             } else {
                                 const pushDirY = Math.sign(overlapY);
                                 pushedY += pushDirY * overlapAmountY * BAT_PLATFORM_PUSH_FORCE * deltaTime;
                                 bat.velocityY *= 0.5;
                             }
                         }
                     }
                 }

                 // Apply Velocity and push adjustments
                 bat.x = nextX + pushedX;
                 bat.y = nextY + pushedY;


                 // Boundary checks (keep within level bounds, above lava)
                 const lavaTop = this.getLavaTopY(bat.x + bat.width/2, this.game.currentTime * 1000);
                 bat.x = clamp(bat.x, 0, this.levelEndX - bat.width);
                 bat.y = clamp(bat.y, 0, lavaTop - bat.height - 5); // Keep slightly above lava waves
             });
         }


        updateGroundPatrollers(deltaTime) {
            for (let i = this.groundPatrollers.length - 1; i >= 0; i--) {
                const patroller = this.groundPatrollers[i];

                 // If health is 0 or less, ensure it's marked for removal or moved off-screen
                if (patroller.health <= 0) {
                    if(patroller.y > -500) { // If not already 'removed'
                        this.effectsSystem.emitBatExplosion(patroller.x + patroller.width / 2, patroller.y + patroller.height / 2, 10, PATROLLER_COLOR);
                        if (game && game.audioCtx) triggerPatrollerDestroy(game.audioCtx.currentTime);
                        patroller.x = -1000; // Move off-screen immediately
                        patroller.y = -1000;
                        patroller.velocityX = 0;
                    }
                    // Consider removing from array here or later after effects
                     // this.groundPatrollers.splice(i, 1); // Option: remove immediately
                    continue; // Skip update for dead patroller
                }

                const platform = patroller.onPlatform;
                if (!platform) {
                    console.warn("Patroller lost its platform link!", patroller);
                     // Attempt to find a nearby platform? Or just remove it.
                    patroller.health = 0; // Mark for removal next frame
                    // this.groundPatrollers.splice(i, 1);
                    continue;
                }

                // Apply reduced friction
                const frictionFactor = Math.pow(0.96, deltaTime * 60); // Adjust friction based on 60fps baseline
                patroller.velocityX *= frictionFactor;
                if (Math.abs(patroller.velocityX) < 0.1) patroller.velocityX = 0;

                // Desired movement speed
                let currentSpeed = PATROLLER_SPEED * patroller.direction * 60; // Convert PATROLLER_SPEED to pixels/sec

                // Combine knockback velocity and desired speed
                let totalVelocityX = patroller.velocityX + currentSpeed * deltaTime; // Apply desired speed over dt
                let nextX = patroller.x + totalVelocityX; // Calculate potential next X

                let reverseDirection = false;

                // Platform boundary checks
                const platformLeftEdge = platform.x;
                const platformRightEdge = platform.x + platform.width;

                if (patroller.direction > 0 && (nextX + patroller.width > platformRightEdge)) {
                    patroller.x = platformRightEdge - patroller.width; // Snap to edge
                    reverseDirection = true;
                    patroller.velocityX = 0; // Stop knockback at edge
                } else if (patroller.direction < 0 && (nextX < platformLeftEdge)) {
                    patroller.x = platformLeftEdge; // Snap to edge
                    reverseDirection = true;
                    patroller.velocityX = 0;
                } else {
                    patroller.x = nextX; // Apply calculated position
                }

                // Check collision with *other* platforms (prevents walking through adjacent platforms)
                for (const otherPlat of this.platforms) {
                    if (otherPlat === platform) continue; // Skip self

                    const patrollerRectNext = {x: patroller.x, y: patroller.y - 1, width: patroller.width, height: patroller.height + 2}; // Slightly larger vertically
                    if (checkRectOverlap(patrollerRectNext, otherPlat)) {
                        // If moving right and overlapping the left edge of otherPlat
                        if (totalVelocityX > 0 && patroller.x + patroller.width > otherPlat.x && patroller.x < otherPlat.x) {
                            patroller.x = otherPlat.x - patroller.width - 0.1; // Place just before the other platform
                            reverseDirection = true;
                            patroller.velocityX = 0;
                            break; // Stop checking other platforms after collision
                        }
                        // If moving left and overlapping the right edge of otherPlat
                        if (totalVelocityX < 0 && patroller.x < otherPlat.x + otherPlat.width && patroller.x + patroller.width > otherPlat.x + otherPlat.width) {
                            patroller.x = otherPlat.x + otherPlat.width + 0.1; // Place just after the other platform
                            reverseDirection = true;
                            patroller.velocityX = 0;
                            break;
                        }
                    }
                }

                // Reverse direction if needed
                if (reverseDirection) {
                    patroller.direction *= -1;
                }

                // Ensure patroller stays vertically aligned with its platform
                patroller.y = platform.y - patroller.height;
            }

            // Optional: Clean up patrollers marked for removal (if not splicing immediately)
            this.groundPatrollers = this.groundPatrollers.filter(p => p.y > -500);
        }


         updateFireballs(dt) { /* ... (keep, but ensure explosion check includes groundPatrollers) ... */
             for (let i = this.fireballs.length - 1; i >= 0; i--) {
                 const fb = this.fireballs[i];
                 if (!fb.active) continue;

                 fb.life -= dt;
                 if (fb.life <= 0) {
                     fb.active = false;
                     this.triggerFireballExplosion(fb.x, fb.y);
                     continue;
                 }

                 fb.x += fb.vx * dt;
                 fb.y += fb.vy * dt;

                 // Check collision with platforms
                 for (const platform of this.platforms) {
                      // More robust check: point vs rect
                     const fbNextX = fb.x + fb.vx * dt; // Predict next pos slightly? Or use current
                     const fbNextY = fb.y + fb.vy * dt;
                     if (fbNextX + fb.radius > platform.x && fbNextX - fb.radius < platform.x + platform.width &&
                         fbNextY + fb.radius > platform.y && fbNextY - fb.radius < platform.y + platform.height) {
                         fb.active = false;
                         this.triggerFireballExplosion(fb.x, fb.y); // Explode slightly before impact point
                         break;
                     }
                 }
                 if (!fb.active) continue;

                 // Check collision with bats
                 for (const bat of this.bats) {
                     if (bat.health > 0 && checkRectOverlap({ x: fb.x - fb.radius, y: fb.y - fb.radius, width: fb.radius * 2, height: fb.radius * 2 }, bat)) {
                         bat.health = 0; // Kill bat instantly
                         // Effects/sound handled in triggerFireballExplosion now via radius check
                         fb.active = false;
                         this.triggerFireballExplosion(fb.x, fb.y);
                         break;
                     }
                 }
                 if (!fb.active) continue;

                 // Check collision with ground patrollers
                 for (const patroller of this.groundPatrollers) {
                      if (patroller.health > 0 && checkRectOverlap({ x: fb.x - fb.radius, y: fb.y - fb.radius, width: fb.radius * 2, height: fb.radius * 2 }, patroller)) {
                           patroller.health = 0; // Kill patroller instantly
                           // Effects/sound handled in triggerFireballExplosion
                           fb.active = false;
                           this.triggerFireballExplosion(fb.x, fb.y);
                           break;
                      }
                 }
             }
             this.fireballs = this.fireballs.filter(fb => fb.active);
         }

         spawnFireball(targetX, targetY) { // Accept target coordinates
            // Cooldown check is now done *before* calling spawnFireball
            // if (this.player.fireballCooldownTimer > 0) return; // This check is moved outside

            const fireball = { ...fireballProto };
            const playerCenterX = this.player.x + this.player.width / 2;
            const playerCenterY = this.player.y + this.player.height / 2; // Use player center

            // Calculate direction from player center to target
            const dirX = targetX - playerCenterX;
            const dirY = targetY - playerCenterY;
            const distance = Math.sqrt(dirX * dirX + dirY * dirY);

            if (distance > 1) { // Only fire if target is not exactly on player
                const normalizedDirX = dirX / distance;
                const normalizedDirY = dirY / distance;

                // Spawn fireball just outside the player radius in the direction of fire
                const spawnDistance = this.player.width / 2 + FIREBALL_RADIUS + 5;
                fireball.x = playerCenterX + normalizedDirX * spawnDistance;
                fireball.y = playerCenterY + normalizedDirY * spawnDistance;

                fireball.vx = normalizedDirX * FIREBALL_SPEED;
                fireball.vy = normalizedDirY * FIREBALL_SPEED;

                // Update player facing direction based on fire direction if not attacking
                 const isAttackingProperty = 'isAttattacking' in this.player ? 'isAttattacking' : 'isAttacking';
                if (!this.player[isAttackingProperty]) {
                    this.player.facingDirection = normalizedDirX >= 0 ? 'right' : 'left';
                }

                fireball.life = FIREBALL_LIFESPAN;
                fireball.active = true;
                this.fireballs.push(fireball);

                this.player.fireballCooldownTimer = FIREBALL_COOLDOWN; // Apply cooldown *after* successful fire

                if (game && game.audioCtx) triggerFireballShoot(game.audioCtx.currentTime);
            } else {
                 console.log("Fireball target too close to player, not firing.");
            }
         }


         triggerFireballExplosion(x, y) {
             this.effectsSystem.emitFireballExplosion(x, y);
             if (game && game.audioCtx) triggerFireballExplode(game.audioCtx.currentTime);

             // Check for nearby enemies in explosion radius
             const explosionRadiusSq = FIREBALL_EXPLOSION_RADIUS * FIREBALL_EXPLOSION_RADIUS;

             // Damage Bats
             for (const bat of this.bats) {
                 if (bat.health > 0) {
                     const dx = (bat.x + bat.width / 2) - x;
                     const dy = (bat.y + bat.height / 2) - y;
                     if (dx * dx + dy * dy < explosionRadiusSq) {
                         bat.health = 0; // Kill bat
                         // Don't emit separate explosion here, main explosion covers it
                         // this.effectsSystem.emitBatExplosion(bat.x + bat.width / 2, bat.y + bat.height / 2);
                     }
                 }
             }
              // Damage Ground Patrollers
              for (const patroller of this.groundPatrollers) {
                 if (patroller.health > 0) {
                     const dx = (patroller.x + patroller.width / 2) - x;
                     const dy = (patroller.y + patroller.height / 2) - y;
                     if (dx * dx + dy * dy < explosionRadiusSq) {
                         patroller.health = 0; // Kill patroller
                         // Effects for patroller death are handled in updateGroundPatrollers check
                         // if (game && game.audioCtx) triggerPatrollerDestroy(game.audioCtx.currentTime);
                     }
                 }
             }
         }

        updateOrbiter(dt) { /* ... (keep) ... */ }

        checkAttackCollisions() {
            // Check consistency: isAttacking vs isAttattacking
            const isAttackingProperty = 'isAttattacking' in this.player ? 'isAttattacking' : 'isAttacking';
             // Don't check collision during the wind-up/wind-down animation frames
            if (!this.player[isAttackingProperty] || this.player.attackTimer <= ATTACK_DURATION * 0.2 || this.player.attackTimer >= ATTACK_DURATION * 0.8) return;

            const hitboxX = (this.player.facingDirection === 'right')
                ? this.player.x + this.player.width * 0.5 + SWORD_HITBOX_OFFSET_X
                : this.player.x + this.player.width * 0.5 - SWORD_HITBOX_OFFSET_X - SWORD_HITBOX_WIDTH;
            const hitboxY = this.player.y + this.player.height * 0.2; // Adjust Y position if needed based on animation
            const attackHitbox = { x: hitboxX, y: hitboxY, width: SWORD_HITBOX_WIDTH, height: SWORD_HITBOX_HEIGHT };

            let hitSomething = false;
            const knockbackDir = (this.player.facingDirection === 'right' ? 1 : -1);

            // Check Bats
            for (const bat of this.bats) {
                if (bat.health > 0 && checkRectOverlap(attackHitbox, bat)) {
                    bat.health = 0; // Sword kills bats instantly
                    // Bat explosion/sound handled in bat update loop when health <= 0
                    // Add knockback to the bat
                    bat.velocityX = knockbackDir * SWORD_KNOCKBACK_STRENGTH * 3; // More knockback for light bats
                    bat.velocityY = SWORD_VERTICAL_KNOCKBACK * 1.5;
                    hitSomething = true;
                     // Bat death effects happen in updateBats
                     // this.effectsSystem.emitBatExplosion(bat.x + bat.width / 2, bat.y + bat.height / 2);
                }
            }

            // Check Ground Patrollers
            for (const patroller of this.groundPatrollers) {
                 // Check health > 0 *before* overlap check for efficiency
                if (patroller.health > 0 && checkRectOverlap(attackHitbox, patroller)) {
                    patroller.health--; // Decrement health
                    this.effectsSystem.emitRewardSparkles(patroller.x + patroller.width / 2, patroller.y + patroller.height / 2, 5, '#ffccaa'); // Hit spark
                    patroller.velocityX = knockbackDir * SWORD_KNOCKBACK_STRENGTH; // Apply horizontal knockback
                    patroller.velocityY = SWORD_VERTICAL_KNOCKBACK; // Apply slight vertical knockback (will be corrected by ground snap)
                    hitSomething = true;
                    if (patroller.health > 0) {
                        if (game && game.audioCtx) triggerPatrollerHit(game.audioCtx.currentTime); // Hit sound
                    }
                     // Patroller death effects happen in updateGroundPatrollers
                }
            }

            if (hitSomething && game && game.audioCtx) {
                triggerSwordHit(game.audioCtx.currentTime); // Play sword hit sound only once if anything was hit
            }
        }


        checkCollisions() {
             // Collectibles
             for (let i = this.collectibles.length - 1; i >= 0; i--) {
                 const collectible = this.collectibles[i];
                 if (!collectible.collected && checkRectOverlap(this.player, collectible)) {
                     collectible.collected = true;
                     this.player.orbShieldCount = clamp(this.player.orbShieldCount + 1, 0, 5); // Max 5 shields? Adjust as needed
                     this.updateOrbShieldDisplay();
                     this.effectsSystem.emitRewardSparkles(collectible.x + collectible.width / 2, collectible.y + collectible.height / 2, 30, collectible.color);
                     // Optional: Play collect sound
                     console.log(`Collected reward! Shield: ${this.player.orbShieldCount}`);
                     // Don't break, allow collecting multiple overlapping ones in theory (unlikely)
                 }
             }

             // Goal
             if (checkRectOverlap(this.player, this.goal)) {
                 if (!this.gameWon) this.winGame();
             }

             // Enemy & Hazard Collisions (only if not invincible from recent hit/shield use)
             if (this.screenFlashTimer <= 0) {
                 // Bats
                 for (const bat of this.bats) {
                     if (bat.health > 0 && checkRectOverlap(this.player, bat)) {
                         this.handlePlayerDamage("bat");
                         return; // Process one hit per frame max
                     }
                 }
                 // Ground Patrollers
                 for (const patroller of this.groundPatrollers) {
                     if (patroller.health > 0 && checkRectOverlap(this.player, patroller)) {
                         this.handlePlayerDamage("patroller");
                         return;
                     }
                 }
                 // Cacti
                 for (const platform of this.platforms) {
                     if (platform.hasCactus) {
                         const cactusRect = {
                             x: platform.x + (platform.width / 2) - (CACTUS_WIDTH / 2),
                             y: platform.y - CACTUS_HEIGHT,
                             width: CACTUS_WIDTH,
                             height: CACTUS_HEIGHT
                         };
                         if (checkRectOverlap(this.player, cactusRect)) {
                             this.handlePlayerDamage("cactus");
                             return;
                         }
                     }
                 }
             }
        }


        checkBoundaries() {
             // Horizontal Boundaries
            if (this.player.x < 0) {
                this.player.x = 0;
                if (this.player.velocityX < 0) this.player.velocityX = 0; // Stop movement into boundary
            }
            if (this.player.x + this.player.width > this.levelEndX) {
                this.player.x = this.levelEndX - this.player.width;
                if (this.player.velocityX > 0) this.player.velocityX = 0;
            }

            // Ceiling Boundary (Top of Canvas)
            if (this.player.y < 0) {
                this.player.y = 0;
                if (this.player.velocityY < 0) this.player.velocityY = 0; // Stop upward movement
            }

            // Lava Boundary (only if not invincible)
            const currentLavaTop = this.getLavaTopY(this.player.x + this.player.width / 2, this.game.currentTime * 1000);
            if (this.screenFlashTimer <= 0 && this.player.y + this.player.height > currentLavaTop) {
                 this.handlePlayerDamage("lava");
            }
        }


        handlePlayerDamage(source = "unknown") {
            if (this.gameWon || this.screenFlashTimer > 0) return; // Already won or invincible

            // Optional: Add brief invincibility even if shield is used?
             const invincibilityDuration = SCREEN_FLASH_DURATION; // Use flash duration

            if (this.player.orbShieldCount > 0) {
                console.log(`Player hit by ${source} - Shield absorbed!`);
                this.player.orbShieldCount--;
                this.updateOrbShieldDisplay();
                this.screenFlashColor = SCREEN_FLASH_COLOR_POWER; // Power flash
                this.screenFlashTimer = invincibilityDuration; // Grant invincibility
                this.triggerOrbBomb(); // Trigger explosion effect
                // Player does NOT restart level, just uses shield
                // Optional: Add a small knockback effect?
                // this.player.velocityY = -5; // Small bounce
            } else {
                console.log(`Player hit by ${source} - Lost a life!`);
                this.player.lives--;
                this.updateLivesDisplay();
                this.screenFlashColor = SCREEN_FLASH_COLOR_DAMAGE; // Damage flash
                this.screenFlashTimer = invincibilityDuration; // Grant invincibility

                if (this.player.lives <= 0) {
                    console.log("Game Over - Restarting Level");
                    this.goToNextLevelOrGameOver(false); // False means Game Over sequence (restart level 1 or show score)
                } else {
                    // Player lost a life but game continues, restart attempt at current level start
                    this.restartCurrentLevelOnDeath(true); // True indicates life loss for logging/sound
                }
            }
             // Optional: Play damage sound effect here
        }

        triggerOrbBomb() { /* ... (keep) ... */ }

        restartCurrentLevelOnDeath(logLifeLoss = true) {
            if(logLifeLoss) console.log("Restarting current level attempt (lost a life)...");
            else console.log("Restarting current level attempt (shield used)..."); // Should not happen with current logic

            if (this.startPlatform) {
                this.player.x = this.startPlatform.x + this.startPlatform.width / 2 - this.player.width / 2;
                this.player.y = this.startPlatform.y - this.player.height - 1;
            } else {
                // Fallback if start platform is missing for some reason
                this.player.x = 100;
                this.player.y = canvas.height - 150;
                console.warn("Start platform not found during restart, using default position.");
            }
            this.player.velocityX = 0;
            this.player.velocityY = 0;
            this.player.onGround = false; // Ensure player starts airborne slightly above platform
            this.player.groundPlatform = null;

            // Reset timers and states
            this.player.animationState = 'idle';
            const isAttackingProperty = 'isAttattacking' in this.player ? 'isAttattacking' : 'isAttacking';
            this.player[isAttackingProperty] = false;
            this.player.attackTimer = 0;
            this.player.attackCooldownTimer = 0; // Allow attacking immediately
            this.player.landingTimer = 0;
            this.player.coyoteTimer = 0;
            this.player.fireballCooldownTimer = 0; // Reset fireball cooldown

            this.orbiterAngle = 0; // Reset orbiter visual
            this.fireballs = []; // Clear active fireballs

            // Reset Enemies to their original positions and states (only if they are still alive)
            this.bats.forEach(bat => {
                if (bat.health > 0) { // Only reset living bats
                    bat.x = bat.originX - bat.width / 2;
                    bat.y = bat.originY - bat.height / 2;
                    bat.velocityX = 0;
                    bat.velocityY = 0;
                    bat.state = (Math.random() < 0.5) ? 'idle' : 'patrolling';
                    [bat.patrolTargetX, bat.patrolTargetY] = getRandomPatrolPoint(bat.originX, bat.originY, bat.patrolRange);
                    bat.stateTimer = getRandom(1, 3);
                }
                 // Dead bats remain dead (at x = -1000)
            });

            this.groundPatrollers.forEach(p => {
                 if (p.health > 0) { // Only reset living patrollers
                     if (p.onPlatform) { // Ensure platform link exists
                         p.x = p.onPlatform.x + p.onPlatform.width / 2 - p.width / 2;
                         p.y = p.onPlatform.y - p.height;
                         p.direction = (Math.random() < 0.5) ? 1 : -1;
                         p.velocityX = 0; // Reset knockback velocity
                     } else {
                         // Patroller lost its platform, remove it or mark dead
                         p.health = 0;
                         p.x = -1000; p.y = -1000;
                     }
                 }
                  // Dead patrollers remain dead
            });

            // Consider resetting collectibles if they should reappear on death?
            // this.collectibles.forEach(c => c.collected = false); // Uncomment if desired
        }


        updateLivesDisplay() { /* ... (keep) ... */ }
        updateOrbShieldDisplay() { /* ... (keep) ... */ }

        winGame() {
             if (this.gameWon) return;
             this.gameWon = true;
             const finalTime = (performance.now() - this.gameStartTime) / 1000;
             messageDiv.textContent = `Level ${this.levelNumber} Clear! ${finalTime.toFixed(2)}s (R for Next)`;
             messageDiv.style.display = 'block';
             this.game.stopMusic();
             this.game.saveSystem.levelCompleted(this.levelNumber, finalTime);
             // Optional: Play win sound/jingle
         }

        goToNextLevelOrGameOver(advanceLevel = false) {
             console.log(`goToNextLevelOrGameOver called. Advance: ${advanceLevel}`);

             if (advanceLevel) {
                 // Player completed the level, move to the next one
                 this.levelNumber = this.game.saveSystem.data.currentLevel; // Gets the *next* level number from save data
                 console.log(`Advancing to level ${this.levelNumber}`);
                 // Lives are carried over, shield is reset in generateLevel
             } else {
                 // Player ran out of lives (Game Over)
                 console.log(`Game Over on level ${this.levelNumber}. Resetting progress.`);
                 // Reset progress (back to level 1, reset score?)
                 this.game.saveSystem.resetProgress(); // Or just reset currentLevel? Decide game over behavior.
                 this.levelNumber = this.game.saveSystem.data.currentLevel; // Should be 1 after reset
                 this.player.lives = STARTING_LIVES; // Reset lives for the new game
                 messageDiv.textContent = `Game Over! (R to Restart)`;
                 messageDiv.style.display = 'block';
                 // No timeout for game over message
                 if (this.messageTimeoutId) clearTimeout(this.messageTimeoutId); this.messageTimeoutId = null;
                 this.game.stopMusic(); // Ensure music is stopped
             }

             // Common cleanup and setup for both cases
             this.gameWon = false;
             // Hide message if advancing, keep if game over
             if(advanceLevel) messageDiv.style.display = 'none';

             if (this.messageTimeoutId && advanceLevel) { // Clear timeout only if advancing
                 clearTimeout(this.messageTimeoutId);
                 this.messageTimeoutId = null;
             }

             this.orbiterAngle = 0;
             this.generateLevel(); // Generate the new level (either next or level 1)
             this.gameStartTime = performance.now(); // Reset timer for the new level

             // Restart music only if advancing, not on game over screen
             if (advanceLevel && this.game.isAudioInitialized && !this.game.isMuted) {
                 this.game.startMusic();
             }
         }

        showTemporaryMessage(text) { /* ... (keep) ... */ }

        render(ctx) {
            const time = this.game.currentTime;
            // Calculate Camera Position (smoothed slightly?)
            // Basic follow:
             let cameraX = this.player.x - canvas.width / 3;
             // Clamp camera to level bounds
             cameraX = clamp(cameraX, 0, Math.max(0, this.levelEndX - canvas.width)); // Ensure levelEndX calc is non-negative
             let cameraY = 0; // No vertical camera movement currently


            // --- Background Layers ---
            this.drawDesertDunesBackground(time * 1000, cameraX, ctx); // Draw desert first

            // --- Lava Layer ---
            this.drawLava(time * 1000, cameraX, ctx); // Lava on top of background, below game elements

            // --- Game World Translation ---
            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            // --- Draw Game Elements (Order matters for layering) ---
            // Platforms & Cacti
            this.platforms.forEach(p => {
                this.drawPlatformSimple(p, ctx);
                if (p.hasCactus) this.drawCactus(p.x + p.width / 2, p.y, ctx);
            });

            // Collectibles (behind enemies/player)
            this.collectibles.forEach(c => {
                if (!c.collected) {
                    const pulse = (1 + Math.sin(time * PULSE_SPEED)) / 2;
                    const r = REWARD_BASE_RADIUS * (1 + pulse * PULSE_MAGNITUDE_ORB);
                    this.drawPulsatingOrb(c.x + c.width / 2, c.y + c.height / 2, r, c.color, time, ctx);
                }
            });

             // Goal Door
            this.drawDoorway(this.goal.x, this.goal.y, this.goal.width, this.goal.height, this.goal.color, time, ctx);

            // Enemies
            this.bats.forEach(b => { if (b.health > 0) this.drawBat(b, ctx); });
            this.groundPatrollers.forEach(p => { if (p.health > 0) this.drawGroundPatroller(p, ctx); });

            // Fireballs
            this.fireballs.forEach(fb => this.drawFireball(fb, ctx));

            // Magic Carpet (if flying)
            if (!this.player.onGround) {
                this.drawMagicCarpet(this.player, time, ctx);
            }

            // Player
            this.drawPlayer(ctx);

            // Orbiters (Shield) - Draw over player
            this.drawOrbiters(time, ctx);

            // Particle Effects
            this.effectsSystem.render(ctx);

            // --- Debug Drawing (Optional) ---
             /*
             if (this.player.isAttacking) { ... } // Keep debug draws commented out for production
             this.debugDrawRect(this.player, '#00FF00', ctx);
             // ... other debug draws ...
             */
            // --- End Debug ---


            // --- Restore Translation ---
            ctx.restore();


            // --- Screen Overlays & UI ---
            // Screen Flash Effect
            if (this.screenFlashTimer > 0 && this.screenFlashColor) {
                const flashAlpha = clamp((this.screenFlashTimer / SCREEN_FLASH_DURATION) * 0.7, 0, 0.7); // Use clamp
                // Ensure color format is rgba
                let colorBase = this.screenFlashColor.startsWith('rgba')
                    ? this.screenFlashColor.substring(0, this.screenFlashColor.lastIndexOf(','))
                    : `rgba(${parseInt(this.screenFlashColor.slice(1,3), 16)},${parseInt(this.screenFlashColor.slice(3,5), 16)},${parseInt(this.screenFlashColor.slice(5,7), 16)}`; // Convert hex/rgb
                 const colorWithAlpha = `${colorBase}, ${flashAlpha.toFixed(2)})`;

                ctx.fillStyle = colorWithAlpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update UI Text (Timer, Lives, Shield)
            this.updateTimerDisplay();
            this.updateLivesDisplay(); // Handles pulsing internally
            this.updateOrbShieldDisplay(); // Handles pulsing internally

            // Render Touch Controls (HTML elements, no canvas drawing needed)
            // if (this.game.touchControls) this.game.touchControls.render(ctx); // No longer needed

            // Win Text Overlay
            if (this.gameWon) {
                 // Win text is now handled by the messageDiv, but could draw overlay here too
                 // this.drawWinTextSimple(ctx);
            }
        }


        updateTimerDisplay() { /* ... (keep) ... */ }

        // --- Drawing Helpers ---
        drawDesertDunesBackground(time, camX, ctx) { /* ... (keep) ... */ }
        drawStarfield(camX, ctx) { /* ... (keep) ... */ }
        getLavaTopY(worldX, time) { /* ... (keep) ... */ }
        drawLava(time, cameraX, ctx) { /* ... (keep) ... */ }
        drawPlatformSimple(platform, ctx) { /* ... (keep) ... */ }
        drawCactus(platformCenterX, platformTopY, ctx) { /* ... (keep) ... */ }
        drawPulsatingOrb(centerX, centerY, radius, color, time, ctx) { /* ... (keep) ... */ }
        drawDoorway(x, y, width, height, frameColor, time, ctx) { /* ... (keep) ... */ }
        drawPlayer(ctx) { /* ... (keep, ensure isAttacking property check is correct) ... */ }
        drawOrbiters(time, ctx) { /* ... (keep) ... */ }
        drawWinTextSimple(ctx) { /* ... (keep) ... */ }
        drawBat(bat, ctx) { /* ... (keep) ... */ }
        drawGroundPatroller(patroller, ctx) { /* ... (keep) ... */ }
        debugDrawRect(rect, color, ctx) { /* ... (keep) ... */ }
        drawMagicCarpet(player, time, ctx) { /* ... (keep) ... */ }
        drawFireball(fb, ctx) { /* ... (keep) ... */ }

    } // End GameplayScene Class

    // --- Game Class ---
    class Game {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.currentScene = null;
            this.scenes = {};
            this.lastTime = 0;
            this.deltaTime = 0;
            this.currentTime = 0; // Seconds since game start (relative to performance.now())
            this.absoluteStartTime = performance.now(); // For consistent time reference
            this.isPaused = false;
            this.isRunning = false;
            this.inputState = { keys: { left: false, right: false, up: false, w: false, space: false, r: false, m: false, x: false, f: false } };
            this.touchControls = null;
            this.isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            this.lastInputType = 'keyboard'; // Track last input type ('keyboard', 'mouse', 'touch')
            this.hasMouseMoved = false; // Track if mouse has moved since start/load

            this.audioCtx = null;
            this.masterGain = null;
            this.distortion = null;
            this.padLfo = null;
            this.padOsc = null;
            this.padGain = null;
            this.musicIntervalId = null;
            this.isAudioInitialized = false;
            this.stepCounter = 0;
            this.isMuted = false;
            this.bassNotes = [0, 0, 3, 0, 5, 0, 3, 0]; // Example bassline
            this.leadNotes = [0, 3, 7, 10, 12, 10, 7, 3]; // Example lead melody segment
            this.saveSystem = new SaveSystem();
            this.mouseX = canvas.width / 2; // Initialize mouse position
            this.mouseY = canvas.height / 2;

            this.initInput();
             if (this.isTouchDevice) {
                 this.touchControls = new TouchControls(this); // Instantiate touch controls if touch device
                 this.lastInputType = 'touch'; // Default to touch if available
             }
        }

        initInput() {
             // Keyboard Listeners
            window.addEventListener('keydown', (e) => {
                if (e.repeat) return; // Ignore repeating keys for single actions
                const key = e.key.toLowerCase();
                let handled = true; // Assume handled unless proven otherwise
                if (key === 'arrowleft' || key === 'a') this.inputState.keys.left = true;
                else if (key === 'arrowright' || key === 'd') this.inputState.keys.right = true;
                else if (key === 'arrowup') this.inputState.keys.up = true;
                else if (key === 'w') this.inputState.keys.w = true;
                else if (key === ' ') this.inputState.keys.space = true;
                else if (key === 'x') this.inputState.keys.x = true;
                else if (key === 'f') this.inputState.keys.f = true;
                else if (key === 'r') { if (!this.inputState.keys.r) this.handleReset(); this.inputState.keys.r = true; }
                else if (key === 'm') { if (!this.inputState.keys.m) this.toggleMute(); this.inputState.keys.m = true; }
                else handled = false; // Key wasn't one of ours

                if (handled) {
                    this.lastInputType = 'keyboard';
                    e.preventDefault(); // Prevent default browser action (scrolling, etc.) for game keys
                }
            });

            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                 if (key === 'arrowleft' || key === 'a') this.inputState.keys.left = false;
                 if (key === 'arrowright' || key === 'd') this.inputState.keys.right = false;
                 if (key === 'arrowup') this.inputState.keys.up = false;
                 if (key === 'w') this.inputState.keys.w = false;
                 if (key === ' ') this.inputState.keys.space = false;
                 if (key === 'x') this.inputState.keys.x = false;
                 if (key === 'f') this.inputState.keys.f = false;
                 if (key === 'r') this.inputState.keys.r = false;
                 if (key === 'm') this.inputState.keys.m = false;
                 // No preventDefault needed on keyup usually
            });

            // Mouse Listeners
            this.canvas.addEventListener('mousemove', (e) => { // Listen on canvas
                const rect = this.canvas.getBoundingClientRect();
                 // Scale mouse coordinates if canvas is scaled by CSS
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                this.mouseX = (e.clientX - rect.left) * scaleX;
                this.mouseY = (e.clientY - rect.top) * scaleY;
                this.lastInputType = 'mouse';
                this.hasMouseMoved = true; // Track that the mouse is active
            });

             // Use mousedown on canvas for firing (prevents firing when clicking outside)
            this.canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    this.lastInputType = 'mouse';
                    // Set a flag or directly trigger, handling happens in update loop now
                    // No direct call to spawnFireball here anymore
                     // Let combinedInput handle it
                     // This could potentially set a 'fireRequested' flag if needed
                     e.preventDefault(); // Prevent canvas drag selection etc.
                }
            });

             // Touch listeners are handled by the TouchControls class now
        }

        handleReset() {
            if (this.currentScene instanceof GameplayScene) {
                this.currentScene.goToNextLevelOrGameOver(this.currentScene.gameWon);
            }
        }
        initAudio() { /* ... (keep) ... */ }
        startMusic() { /* ... (keep, ensure checks for isRunning) ... */
            if (!this.isAudioInitialized || this.musicIntervalId !== null || this.isMuted || !this.isRunning) { return; }
             console.log("StartMusic: Starting music interval.");
             this.stepCounter = 0;
             const intervalMilliseconds = SIXTEENTH_NOTE_DURATION * 1000;
             if (this.musicIntervalId) clearInterval(this.musicIntervalId);
             // Ensure 'this' context is correct for the sequencer
             const boundSequencer = musicSequencer.bind(this);
             boundSequencer(); // Call immediately once
             this.musicIntervalId = setInterval(boundSequencer, intervalMilliseconds);
        }
        stopMusic() { /* ... (keep) ... */ }
        toggleMute() { /* ... (keep, ensure music restart logic respects isRunning) ... */
            if (!this.isAudioInitialized || !this.masterGain) return;
             this.isMuted = !this.isMuted;
             const targetVolume = this.isMuted ? 0.001 : MASTER_VOLUME;
             const now = this.audioCtx.currentTime;
             this.masterGain.gain.cancelScheduledValues(now);
             this.masterGain.gain.linearRampToValueAtTime(targetVolume, now + 0.1);
             console.log("Muted:", this.isMuted);

             if (this.isMuted) {
                 this.stopMusic();
             } else {
                 // Only start music if game is actually running and in gameplay scene
                 if (this.isRunning && this.currentScene instanceof GameplayScene && !this.currentScene.gameWon) {
                     this.startMusic();
                 }
             }
        }
        addScene(name, scene) { /* ... (keep) ... */ }
        setScene(name) { /* ... (keep) ... */ }

        gameLoop(timestamp) {
             if (!this.isRunning) { return; }

             // Calculate deltaTime and currentTime
             if (!this.lastTime) this.lastTime = timestamp;
             const rawDeltaTime = (timestamp - this.lastTime) / 1000;
             this.lastTime = timestamp;
             this.deltaTime = Math.min(rawDeltaTime, MAX_DELTA_TIME); // Clamp delta time
             this.currentTime = (timestamp - this.absoluteStartTime) / 1000.0; // Time since game.start()

             try {
                 // Update current scene if not paused
                 if (!this.isPaused && this.currentScene) {
                     this.currentScene.update(this.deltaTime);
                 }

                 // Render current scene
                 if (this.currentScene) {
                      // Clear canvas before drawing new frame
                      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // Important!
                      this.currentScene.render(this.ctx);
                 }

                 // Request next frame
                 requestAnimationFrame(this.gameLoop.bind(this));

             } catch (error) {
                 console.error("CRITICAL ERROR in game loop:", error);
                 this.stop(); // Stop the game loop on critical error
                 alert("A critical error occurred during the game loop. Check console for details.");
             }
         }

        start() {
             if (this.isRunning) { return; }
             console.log("Game.start: Initializing game loop...");
             this.isRunning = true;
             this.lastTime = 0; // Reset lastTime for correct first deltaTime
             this.absoluteStartTime = performance.now(); // Reset absolute start time
             this.currentTime = 0;
             console.log("Game.start: Requesting first animation frame.");
             requestAnimationFrame(this.gameLoop.bind(this));

             // Start music if conditions are met
             if (this.isAudioInitialized && !this.isMuted && this.currentScene instanceof GameplayScene && !this.currentScene.gameWon) {
                 this.startMusic();
             }
         }

        stop() {
             if (!this.isRunning) return;
             console.log("Game.stop: Stopping game loop and music...");
             this.isRunning = false; // This will stop the requestAnimationFrame chain
             this.stopMusic();
             // No need to cancel animation frame explicitly if isRunning check is at the start of gameLoop
        }
    }

    // --- Startup Self-Test ---
    function runStartupTests() { /* ... (keep) ... */ }

    // --- Main Execution ---
    let game;
    if (runStartupTests()) {
        console.log("Initializing Game...");
        game = new Game(canvas); // Game instance created
        console.log("Adding scenes...");
        game.addScene('gameplay', new GameplayScene()); // Add gameplay scene
        console.log("Scenes added.");

        console.log("Setting up audio overlay listener...");
        audioOverlay.addEventListener('click', () => {
            console.log("--- Overlay clicked ---");
            audioOverlay.style.display = 'none'; // Hide overlay immediately

            try {
                // 1. Initialize Audio if needed (and resume)
                if (!game.isAudioInitialized) {
                    console.log("Overlay: Initializing audio...");
                    game.initAudio();
                    // Resume might be needed immediately after init if suspended by browser policy
                    if (game.audioCtx && game.audioCtx.state === 'suspended') {
                         console.log("Overlay: Attempting resume after init...");
                         game.audioCtx.resume().then(() => {
                             console.log("AudioContext resumed successfully after init.");
                             // Don't start music yet, wait for game.start()
                         }).catch(err => console.error("Overlay: Resume after init failed:", err));
                     }
                } else if (game.audioCtx && game.audioCtx.state === 'suspended') {
                     // If audio was initialized before but suspended, resume it
                    console.log("Overlay: AudioContext suspended, attempting resume...");
                    game.audioCtx.resume().then(() => {
                        console.log("AudioContext resumed successfully.");
                         // Don't start music yet
                    }).catch(err => console.error("Overlay: AudioContext resume failed:", err));
                }

                // 2. Set Initial Scene if not already set
                if (!game.currentScene) {
                    console.log("Overlay: Setting initial scene to gameplay...");
                    game.setScene('gameplay');
                    if (!game.currentScene) { // Double-check scene was set
                        throw new Error("Failed to set the initial scene 'gameplay'.");
                    }
                }

                // 3. Start the Game Loop (which will handle music start internally)
                if (!game.isRunning) {
                    console.log("Overlay: Calling game.start()...");
                    game.start(); // Start the game loop and logic
                }
                // If game was already running (e.g., paused/resumed?), ensure music is correct
                 else if(game.isAudioInitialized && !game.isMuted && game.musicIntervalId === null){
                     console.log("Overlay: Game was already running, attempting music sync...");
                     if (game.currentScene instanceof GameplayScene && !game.currentScene.gameWon) {
                         game.startMusic();
                     }
                 }


                console.log("--- Overlay handler finished ---");

            } catch (error) {
                console.error("CRITICAL ERROR during overlay click handler:", error);
                alert("An error occurred starting the game. Check the console for details.");
                if(game && game.stop) game.stop(); // Attempt to stop if something went wrong
            }
        }, { once: true }); // Only allow the overlay to be clicked once

        console.log("Initial setup complete. Waiting for user interaction via overlay.");

    } else {
        // Startup tests failed
        alert("Core game components failed to load. Check the developer console (F12) for errors.");
        console.error("Startup tests failed. Game cannot start.");
    }

</script>

</body>
</html>