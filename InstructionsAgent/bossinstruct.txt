Instructions:

Add Score Display (HTML/CSS):

In the HTML <body>, add a new div for the score display, similar to the timer and lives. Let's place it in the top-left.

<!-- Add this line after the #orbShieldDisplay div -->
<div id="scoreDisplay">Score: 0</div>


In the CSS <style> block, add styling for the new #scoreDisplay.

/* Add this CSS rule */
    #scoreDisplay {
        position: absolute;
        top: 10px; /* Align with timer top */
        left: 15px; /* Position on the left */
        color: #ffdd99; /* Score color - light gold */
        font-size: 20px; /* Match timer size */
        font-family: monospace;
        text-shadow: 1px 1px 2px #000;
        z-index: 5;
    }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Css
IGNORE_WHEN_COPYING_END

Add Score Variable and Display Function (GameplayScene):

Get the new DOM element: Add scoreDisplayDiv to the list of DOM elements at the top of the <script>.

// --- DOM Elements ---
// ... (keep existing)
const livesDisplayDiv = document.getElementById('livesDisplay');
const orbShieldDisplayDiv = document.getElementById('orbShieldDisplay');
const scoreDisplayDiv = document.getElementById('scoreDisplay'); // Add this line
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Add score property to GameplayScene constructor:

class GameplayScene extends Scene {
    constructor() {
        super();
        // ... (other properties)
        this.boss = null;
        this.score = 0; // <<< Add this line
    }
    // ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Reset score in generateLevel: Add score reset at the beginning of the method.

generateLevel() {
         console.log("GameplayScene.generateLevel called (Full Reset).");
         this.boss = null;
         this.score = 0; // <<< Reset score here
         this.updateScoreDisplay(); // Update display to show 0
         try {
             // ... rest of generateLevel
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Create updateScoreDisplay method in GameplayScene:

// Add this method inside GameplayScene class
    updateScoreDisplay() {
        if (scoreDisplayDiv) {
            scoreDisplayDiv.textContent = `Score: ${this.score}`;
        }
    }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Call updateScoreDisplay in render: Add this call near the end of the render method, alongside other UI updates.

render(ctx) {
        // ... (existing rendering code) ...
        ctx.restore(); // Restore from camera translation

        // Screen Flash logic (keep existing)
        if (this.screenFlashTimer > 0 && this.screenFlashColor) { /* ... */ }

        // Update UI Displays
        this.updateTimerDisplay();
        this.updateLivesDisplay();
        this.updateOrbShieldDisplay();
        this.updateScoreDisplay(); // <<< Add this call

        // Touch controls and Win Text (keep existing)
        if (this.game.touchControls) this.game.touchControls.render(ctx);
        if (this.gameWon) {
             this.drawWinScreen(ctx); // Use the improved win screen draw function
        }
    }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Award Points for Enemy Kills:

Point Constants: Define point values near other gameplay constants.

// --- Point Values ---
const POINTS_BAT = 50;
const POINTS_SNAKE = 75;
const POINTS_PATROLLER = 60; // Assigning a value for patrollers
const POINTS_BOSS = 500;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

In checkAttackCollisions: Award points when health is set to 0 for the first time.

checkAttackCollisions() {
    // ... (get hitbox) ...
    let hitSomething = false; const knockbackDir = (this.player.facingDirection === 'right' ? 1 : -1);

    // Bats
    for (const bat of this.bats) {
        if (bat.health > 0 && checkRectOverlap(attackHitbox, bat)) {
            bat.health = 0;
            this.score += POINTS_BAT; // Award points
            this.updateScoreDisplay(); // Update display
            this.effectsSystem.emitBatExplosion(bat.x + bat.width / 2, bat.y + bat.height / 2);
            bat.velocityX = knockbackDir * SWORD_KNOCKBACK_STRENGTH; bat.velocityY = SWORD_VERTICAL_KNOCKBACK; hitSomething = true;
        }
    }

    // Patrollers (Damage only, points awarded on actual removal)
    for (const patroller of this.groundPatrollers) {
        if (patroller.health > 0 && checkRectOverlap(attackHitbox, patroller)) {
            patroller.health--;
            this.effectsSystem.emitRewardSparkles(patroller.x + patroller.width/2, patroller.y + patroller.height/2, 5, '#ffccaa');
            patroller.velocityX = knockbackDir * SWORD_KNOCKBACK_STRENGTH; hitSomething = true;
            if (patroller.health > 0) {
                if (game && game.audioCtx) triggerPatrollerHit(game.audioCtx.currentTime);
            }
            // No points awarded here per hit
        }
    }

    // Snakes
    for (const snake of this.snakes) {
        if (snake.health > 0 && checkRectOverlap(attackHitbox, snake)) {
            snake.health = 0;
            this.score += POINTS_SNAKE; // Award points
            this.updateScoreDisplay(); // Update display
            this.effectsSystem.emitBatExplosion(snake.x + snake.width / 2, snake.y + snake.height / 2, 10, SNAKE_COLOR);
            hitSomething = true;
            // Add knockback if desired
            snake.velocityX = knockbackDir * SWORD_KNOCKBACK_STRENGTH * 0.8;
            snake.velocityY = SWORD_VERTICAL_KNOCKBACK * 0.8;
        }
    }

    // Boss Hit (handled in handleBossHit, points awarded on defeat)
    if (!hitSomething && this.boss && !this.boss.isDefeated && this.boss.health > 0 && checkRectOverlap(attackHitbox, this.boss)) {
        this.handleBossHit(knockbackDir); // Calls the handler
        hitSomething = true;
    }

    // Sound trigger (keep existing)
    if (hitSomething && game && game.audioCtx) { /* ... */ }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

In updateFireballs: Award points when health is set to 0 for the first time.

updateFireballs(dt) {
    for (let i = this.fireballs.length - 1; i >= 0; i--) {
        const fb = this.fireballs[i];
        // ... (update position, check life) ...

        // Platform collision (keep existing)

        // Check collision with bats
        for (const bat of this.bats) {
             // Check health > 0 BEFORE overlap check to avoid double points if hit multiple times per frame somehow
             if (!fb.active) break; // Stop checking if fireball already exploded
             if (bat.health > 0 && checkRectOverlap({ /* fireball rect */ }, bat)) {
                bat.health = 0; // Kill bat
                this.score += POINTS_BAT; // Award points
                this.updateScoreDisplay(); // Update display
                this.effectsSystem.emitBatExplosion(bat.x + bat.width / 2, bat.y + bat.height / 2);
                fb.active = false;
                this.triggerFireballExplosion(fb.x, fb.y);
                break; // Stop checking enemies for this fireball
            }
        }
        // if (!fb.active) continue; // Redundant check, handled by break

        // Check collision with ground patrollers
        for (const patroller of this.groundPatrollers) {
            if (!fb.active) break;
             if (patroller.health > 0 && checkRectOverlap({ /* fireball rect */ }, patroller)) {
                 // Only award points if this hit KILLS it
                 const healthBeforeHit = patroller.health;
                 patroller.health = 0; // Kill patroller immediately with fireball
                 if (healthBeforeHit > 0) { // Check if it wasn't already dead
                     // Points are awarded in updateGroundPatrollers when removed
                 }
                 this.effectsSystem.emitBatExplosion(patroller.x + patroller.width / 2, patroller.y + patroller.height / 2, 10, PATROLLER_COLOR);
                 if (game && game.audioCtx) triggerPatrollerDestroy(game.audioCtx.currentTime);
                 fb.active = false;
                 this.triggerFireballExplosion(fb.x, fb.y);
                 break;
             }
        }
        // if (!fb.active) continue;

        // Check collision with snakes
        for (const snake of this.snakes) {
            if (!fb.active) break;
            if (snake.health > 0 && checkRectOverlap({ /* fireball rect */ }, snake)) {
                snake.health = 0; // Kill snake
                this.score += POINTS_SNAKE; // Award points
                this.updateScoreDisplay(); // Update display
                this.effectsSystem.emitBatExplosion(snake.x + snake.width / 2, snake.y + snake.height / 2, 10, SNAKE_COLOR);
                fb.active = false;
                this.triggerFireballExplosion(fb.x, fb.y);
                break;
            }
        }
        // if (!fb.active) continue;

        // Check collision with Giant Bat Boss (Damage only, points on defeat)
        if (this.boss && !this.boss.isDefeated && this.boss.health > 0 && checkRectOverlap({ /* fireball rect */ }, this.boss)) {
             if (!fb.active) { /* Handle potential multi-hit if fireball didn't break */ }
             else {
                 this.handleBossHit(0); // Fireball hit, no knockback direction
                 fb.active = false;
                 this.triggerFireballExplosion(fb.x, fb.y);
                 // No break here needed if fireball explodes
             }
        }
    } // End of fireball loop
    this.fireballs = this.fireballs.filter(fb => fb.active);
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

In updateGroundPatrollers: Award points just before splicing.

```javascript
    updateGroundPatrollers(deltaTime) {
        for (let i = this.groundPatrollers.length - 1; i >= 0; i--) {
            const patroller = this.groundPatrollers[i];
            if (patroller.health <= 0) {
                this.score += POINTS_PATROLLER; // <<< Award points here
                this.updateScoreDisplay();    // <<< Update display here
                this.effectsSystem.emitBatExplosion(patroller.x + patroller.width / 2, patroller.y + patroller.height / 2, 10, PATROLLER_COLOR);
                if (game && game.audioCtx) triggerPatrollerDestroy(game.audioCtx.currentTime);
                this.groundPatrollers.splice(i, 1);
                continue;
            }
            // ... rest of the patroller update logic ...
        }
    }
```

*   **In `triggerOrbBomb`:** Award points when health is set to 0 *for the first time*.

```javascript
triggerOrbBomb() {
    // ... (get center, radius) ...
    // Bats
    for (let i = this.bats.length - 1; i >= 0; i--) {
        const bat = this.bats[i];
        if (bat.health > 0) {
            // ... (check distance) ...
            if (distSq < destroyRadiusSq) {
                bat.health = 0;
                this.score += POINTS_BAT; // Award points
                batsDestroyed++;
                this.effectsSystem.emitBatExplosion(batCenterX, batCenterY);
            }
        }
    }
    // Snakes
    for (let i = this.snakes.length - 1; i >= 0; i--) {
        const snake = this.snakes[i];
         if (snake.health > 0) {
            // ... (check distance) ...
            if (distSq < destroyRadiusSq) {
                snake.health = 0;
                this.score += POINTS_SNAKE; // Award points
                snakesDestroyed++;
                this.effectsSystem.emitBatExplosion(snakeCenterX, snakeCenterY, 10, SNAKE_COLOR);
            }
        }
    }
    // Boss (Damage only via Orb Bomb, points awarded on actual defeat)
    if (this.boss && this.boss.health > 0) {
        // ... (check distance) ...
         if (distSq < destroyRadiusSq) {
             this.handleBossHit(0); // Deals 1 damage via the handler, no points here
         }
    }

    this.effectsSystem.emitPlayerBombExplosion(playerCenterX, playerCenterY);
    this.updateScoreDisplay(); // Update display after all potential point awards
    console.log(`Bomb destroyed ${batsDestroyed} bats and ${snakesDestroyed} snakes.`);
 }
```

*   **In `handleBossDefeat`:** Award the boss points.

```javascript
    handleBossDefeat() {
        if (!this.boss || this.boss.isDefeated) return; // Prevent double execution

        console.log("Giant Bat Boss Defeated!");
        this.boss.isDefeated = true;
        this.boss.health = 0;

        this.score += POINTS_BOSS; // <<< Award boss points
        this.updateScoreDisplay(); // <<< Update display

        // ... (rest of defeat logic: move off screen, effects, sounds) ...

         // Optional: Drop final reward orb (keep existing)
         // ...
    }
```
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Improve Win Screen:

Store Final Score in winGame:

winGame() {
    if (this.gameWon) return;
    this.gameWon = true;
    const finalTime = (performance.now() - this.gameStartTime) / 1000;
    this.finalScore = this.score; // <<< Store the final score
    this.finalTimeStr = finalTime.toFixed(2); // Store final time string

    // Update message div immediately if needed, or rely on drawWinScreen
    messageDiv.textContent = `You Win!`; // Simpler message here now
    messageDiv.style.display = 'block';

    this.game.stopMusic();
    this.game.saveSystem.levelCompleted(this.levelNumber, this.finalTimeStr);
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Replace drawWinTextSimple with drawWinScreen:

// Replace the old drawWinTextSimple method with this one:
    drawWinScreen(ctx) {
        ctx.save();
        const boxPadding = 30;
        const boxWidth = 400;
        const boxHeight = 200;
        const boxX = canvas.width / 2 - boxWidth / 2;
        const boxY = canvas.height / 2 - boxHeight / 2;

        // Semi-transparent background box
        ctx.fillStyle = 'rgba(10, 20, 40, 0.85)';
        ctx.strokeStyle = GOAL_FRAME_COLOR; // Use goal color for border
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(150, 200, 255, 0.5)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        ctx.shadowColor = 'transparent'; // Reset shadow

        // Title Text
        ctx.fillStyle = WIN_TEXT_COLOR;
        ctx.font = 'bold 50px sans-serif'; // Slightly smaller font
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.7)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.fillText("LEVEL COMPLETE!", canvas.width / 2, boxY + boxPadding + 25);

        // Score and Time Text
        ctx.font = 'bold 28px monospace'; // Monospace for score/time alignment
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top'; // Align from top for easier spacing
        ctx.shadowColor = 'transparent'; // Less shadow for score details

        const timeText = `Time:  ${this.finalTimeStr || '0.00'}s`;
        const scoreText = `Score: ${this.finalScore || 0}`;
        const textYStart = boxY + boxPadding + 70; // Position below title
        const textXStart = boxX + boxPadding + 20;

        ctx.fillText(timeText, textXStart, textYStart);
        ctx.fillText(scoreText, textXStart, textYStart + 40); // Space them out

        // Prompt Text
        ctx.font = '18px sans-serif';
        ctx.fillStyle = '#bbddff';
        ctx.textAlign = 'center';
        ctx.fillText("(Press R for Next Level)", canvas.width / 2, boxY + boxHeight - boxPadding);


        ctx.restore();
    }

    // --- Remove the old drawWinTextSimple method ---
    // drawWinTextSimple(ctx) { /* ... */ }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Update render call: Make sure the call in render uses the new function name drawWinScreen. (We already did this in step 2).

Final Check:

Ensure all point awards call this.updateScoreDisplay().

Ensure score is reset correctly in generateLevel.

Test the win screen layout to confirm score and time are displayed clearly without overlapping the "LEVEL COMPLETE!" text.

Confirm points are awarded correctly for each enemy type upon their removal/defeat.

You now have a scoring system and an improved win screen, agent!