1. Update Player State:

Add a selectedWeapon property to the player object initialization.

      
// --- Initial Game Object States ---
    const player = {
        x: 100, y: canvas.height - 100, width: 20, height: 45, velocityX: 0, velocityY: 0,
        onGround: false, groundPlatform: null, facingDirection: 'right', animationState: 'idle',
        animationTimer: 0, animationFrameIndex: 0, isAttacking: false, attackTimer: 0,
        attackCooldownTimer: 0, landingTimer: 0, coyoteTimer: 0, lives: STARTING_LIVES,
        orbShieldCount: 0, fireballCooldownTimer: 0, lightningBoltCooldownTimer: 0,
        selectedWeapon: 1 // <-- ADD THIS LINE (Start with Fireball)
    };
    // ... rest of the initial states

    

IGNORE_WHEN_COPYING_START
Use code with caution.JavaScript
IGNORE_WHEN_COPYING_END

2. Add Weapon Display UI:

Add a new div element in the HTML <body> for displaying the current weapon.

      
<!-- Add this div alongside the others -->
<div id="weaponDisplay">Weapon: 1 (Fireball)</div>

<canvas id="gameCanvas"></canvas>

<script>
    // ... script start

    

IGNORE_WHEN_COPYING_START
Use code with caution.Html
IGNORE_WHEN_COPYING_END

Add basic styling for it in the <style> section:

      
/* Add this style rule */
    #weaponDisplay { position: absolute; top: 80px; right: 15px; color: #ffcc66; font-size: 16px; font-family: monospace; text-shadow: 1px 1px 2px #000; z-index: 5; }
</style>

    

IGNORE_WHEN_COPYING_START
Use code with caution.Css
IGNORE_WHEN_COPYING_END

Get the DOM element reference at the start of the script:

      
// --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas');
    // ... other elements
    const weaponDisplayDiv = document.getElementById('weaponDisplay'); // <-- ADD THIS LINE

    

IGNORE_WHEN_COPYING_START
Use code with caution.JavaScript
IGNORE_WHEN_COPYING_END

3. Modify Input Handling (Game.initInput):

    Keys '1' through '5' will now select the weapon within the GameplayScene.

    The mousedown listener will trigger the selected ranged weapon attack.

    Key 'X' remains for melee attack.

      
initInput() {
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                // Weapon Selection Keys (handled within GameplayScene update now)
                if (key >= '1' && key <= '5') {
                    // We'll read this key state in GameplayScene.updatePlayer
                    this.inputState.keys[`num${key}`] = true; // Use a specific key name like 'num1', 'num2'
                }
                // Movement and Melee
                if (key === 'arrowleft' || key === 'a') this.inputState.keys.left = true;
                if (key === 'arrowright' || key === 'd') this.inputState.keys.right = true;
                if (key === 'arrowup') this.inputState.keys.up = true;
                if (key === 'w') this.inputState.keys.w = true;
                if (key === ' ') this.inputState.keys.space = true;
                if (key === 'x') this.inputState.keys.x = true; // Keep X for melee
                // Other Keys
                if (key === 'r') {
                    if (!this.inputState.keys.r) this.handleReset();
                    this.inputState.keys.r = true;
                }
                if (key === 'm') {
                    if (!this.inputState.keys.m) this.toggleMute();
                    this.inputState.keys.m = true;
                }
            });

            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                // Weapon Selection Keys
                if (key >= '1' && key <= '5') {
                    this.inputState.keys[`num${key}`] = false;
                }
                // Movement and Melee
                if (key === 'arrowleft' || key === 'a') this.inputState.keys.left = false;
                if (key === 'arrowright' || key === 'd') this.inputState.keys.right = false;
                if (key === 'arrowup') this.inputState.keys.up = false;
                if (key === 'w') this.inputState.keys.w = false;
                if (key === ' ') this.inputState.keys.space = false;
                if (key === 'x') this.inputState.keys.x = false;
                 // Other Keys
                if (key === 'r') this.inputState.keys.r = false;
                if (key === 'm') this.inputState.keys.m = false;
            });

            window.addEventListener('mousemove', (e) => {
                const rect = this.canvas.getBoundingClientRect();
                // Scale mouse coordinates if canvas is scaled via CSS
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                this.mouseX = (e.clientX - rect.left) * scaleX;
                this.mouseY = (e.clientY - rect.top) * scaleY;
            });

            window.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button for ranged attacks
                    if (this.currentScene instanceof GameplayScene) {
                        // Delegate the ranged attack action to the scene
                        this.currentScene.handleRangedAttack();
                    }
                }
            });

            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                this.touchControls = new TouchControls(this);
                // Potentially add touch zones for weapon switching and ranged attack
            }

            // Apply the magic cursor directly to canvas once
            if (this.canvas) {
                this.canvas.classList.add('magic-cursor');
            }
        }

    

IGNORE_WHEN_COPYING_START
Use code with caution.JavaScript
IGNORE_WHEN_COPYING_END

4. Update GameplayScene for Weapon Switching and Mouse Aiming:

    Add handleRangedAttack method.

    Modify updatePlayer to handle weapon selection keys and remove direct attack triggers from number keys.

    Modify spawnFireball to use mouse coordinates for aiming.

    Add updateWeaponDisplay method.

      
// --- Gameplay Scene ---
    class GameplayScene extends Scene {
        constructor() {
            super();
            this.player = { ...player }; // Player object is copied here
            this.platforms = [];
            this.collectibles = [];
            this.bats = [];
            this.groundPatrollers = [];
            this.snakes = [];
            this.goal = { ...goal };
            this.stars = [];
            this.fireballs = [];
            this.lightningBolts = [];
            this.boss = null;
            this.cameraX = 0; // Keep track of camera position
        }

        onEnter() {
            // ... (existing onEnter code) ...
            this.player.selectedWeapon = 1; // Ensure weapon resets on level entry/retry
            this.updateWeaponDisplay(); // Initial display update
            // ...
         }

        // ... (onExit, generateLevel, updateLivesDisplay, updateOrbShieldDisplay, initStars remain mostly the same)

        // --- NEW: Update Weapon Display ---
        updateWeaponDisplay() {
            if (weaponDisplayDiv) {
                let weaponName = "Unknown";
                switch(this.player.selectedWeapon) {
                    case 1: weaponName = "Fireball"; break;
                    case 2: weaponName = "Lightning"; break;
                    case 3: weaponName = "Weapon 3"; break; // Placeholder
                    case 4: weaponName = "Weapon 4"; break; // Placeholder
                    case 5: weaponName = "Weapon 5"; break; // Placeholder
                }
                 weaponDisplayDiv.textContent = `Weapon: ${this.player.selectedWeapon} (${weaponName})`;
            }
        }


        update(deltaTime) {
            if (this.gameWon) return;
            if (this.screenFlashTimer > 0) { this.screenFlashTimer -= deltaTime; }

            const kbdInput = this.game.inputState.keys;
            const touchInput = this.game.touchControls ? this.game.touchControls.getInput() : { left: false, right: false, space: false, attack: false };
            const jumpOrFlyInput = kbdInput.space || kbdInput.up || kbdInput.w || touchInput.space;

            // Define input actions based on keys/touch
            const combinedInput = {
                left: kbdInput.left || touchInput.left,
                right: kbdInput.right || touchInput.right,
                jumpOrFly: jumpOrFlyInput,
                meleeAttack: kbdInput.x, // Melee attack is only key 'X'
                // Ranged attack is handled by handleRangedAttack() via mouse click
                selectWeapon1: kbdInput.num1, // Check for num keys set in Game.initInput
                selectWeapon2: kbdInput.num2,
                selectWeapon3: kbdInput.num3,
                selectWeapon4: kbdInput.num4,
                selectWeapon5: kbdInput.num5,
            };


            this.updatePlayer(deltaTime, combinedInput);
            this.updateBats(deltaTime);
            this.updateGroundPatrollers(deltaTime);
            this.updateSnakes(deltaTime);
            this.updateFireballs(deltaTime);
            this.updateLightningBolts(deltaTime);
            this.updateGiantBatBoss(deltaTime);
            if (this.player.isAttacking) { // This is now only for melee
                this.checkMeleeAttackCollisions(); // Rename if needed, or keep generic
            }
            this.effectsSystem.update(deltaTime);
            this.powerUpSystem.update(deltaTime);
            this.updateOrbiter(deltaTime);
            this.checkCollisions();
            this.checkBoundaries();

            // Update camera position (needed for mouse aiming)
            this.cameraX = this.player.x - canvas.width / 3;
            this.cameraX = Math.max(0, Math.min(this.levelEndX - canvas.width, this.cameraX));
        }

        updatePlayer(dt, input) {
            // --- Timers ---
            if (this.player.attackCooldownTimer > 0) this.player.attackCooldownTimer -= dt; // Melee cooldown
            if (this.player.attackTimer > 0) this.player.attackTimer -= dt; // Melee duration
            if (this.player.landingTimer > 0) this.player.landingTimer -= dt;
            if (this.player.coyoteTimer > 0) this.player.coyoteTimer -= dt;
            if (this.player.fireballCooldownTimer > 0) this.player.fireballCooldownTimer -= dt;
            if (this.player.lightningBoltCooldownTimer > 0) this.player.lightningBoltCooldownTimer -= dt;

            // --- Weapon Selection ---
            let weaponChanged = false;
            if (input.selectWeapon1 && this.player.selectedWeapon !== 1) { this.player.selectedWeapon = 1; weaponChanged = true; }
            else if (input.selectWeapon2 && this.player.selectedWeapon !== 2) { this.player.selectedWeapon = 2; weaponChanged = true; }
            else if (input.selectWeapon3 && this.player.selectedWeapon !== 3) { this.player.selectedWeapon = 3; weaponChanged = true; }
            else if (input.selectWeapon4 && this.player.selectedWeapon !== 4) { this.player.selectedWeapon = 4; weaponChanged = true; }
            else if (input.selectWeapon5 && this.player.selectedWeapon !== 5) { this.player.selectedWeapon = 5; weaponChanged = true; }

            if (weaponChanged) {
                console.log("Selected Weapon:", this.player.selectedWeapon);
                this.updateWeaponDisplay(); // Update UI when weapon changes
            }

            // --- Melee Attack State ---
            // Reset attack state only if the melee attack timer runs out
            if (this.player.isAttacking && this.player.attackTimer <= 0) {
                 this.player.isAttacking = false;
            }
            // Trigger melee attack with 'X' key
            if (input.meleeAttack && !this.player.isAttacking && this.player.attackCooldownTimer <= 0) {
                this.player.isAttacking = true; // Set flag for melee animation/hitbox
                this.player.attackTimer = ATTACK_DURATION;
                this.player.attackCooldownTimer = ATTACK_DURATION + ATTACK_COOLDOWN;
                if (game && game.audioCtx) triggerSwordSwing(game.audioCtx.currentTime);
            }

            // --- Ranged Attacks (Removed from here, handled by handleRangedAttack) ---
            // REMOVED: Fireball Shooting check (input.shoot)
            // REMOVED: Lightning Bolt Attack check (input.lightningAttack)

            const wasOnGround = this.player.onGround;

            // --- Horizontal Movement ---
            let targetVelX = this.player.velocityX;
            // Use MELEE attack state to affect movement speed slightly if desired
            const currentAccel = this.player.onGround ? GROUND_ACCELERATION : AIR_ACCELERATION;
            const currentMaxSpeed = this.player.onGround ? GROUND_MAX_SPEED : AIR_MAX_SPEED;
            const currentFriction = this.player.onGround ? GROUND_FRICTION : AIR_FRICTION;
            // Maybe reduce accel less drastically during melee than original code
            const effectiveAccel = this.player.isAttacking ? currentAccel * 0.7 : currentAccel;

            if (input.left) { targetVelX -= effectiveAccel; this.player.facingDirection = 'left'; }
            else if (input.right) { targetVelX += effectiveAccel; this.player.facingDirection = 'right'; }
            else { targetVelX *= currentFriction; }
            this.player.velocityX = Math.max(-currentMaxSpeed, Math.min(currentMaxSpeed, targetVelX));
            if (Math.abs(this.player.velocityX) < 0.1) this.player.velocityX = 0;

            // --- Vertical Movement (Gravity) ---
            // Player cannot fly while performing melee attack
            const holdingFlyInAir = input.jumpOrFly && !this.player.onGround && !this.player.isAttacking;
            const currentGravity = holdingFlyInAir ? gravity * FLYING_GRAVITY_MULTIPLIER : gravity;
            this.player.velocityY += currentGravity;

            // --- Jumping & Flying ---
            const canJump = this.player.onGround || this.player.coyoteTimer > 0;
            // Cannot start jump/fly during melee attack animation
            if (input.jumpOrFly && !this.player.isAttacking) {
                 if (canJump) { this.player.velocityY = -JUMP_STRENGTH; this.player.coyoteTimer = 0; this.player.onGround = false; if (game && game.audioCtx) triggerJumpSound(game.audioCtx.currentTime); }
                 else if (!this.player.onGround) { this.player.velocityY -= FLY_STRENGTH; this.player.velocityY = Math.max(-MAX_FLY_SPEED, this.player.velocityY); }
            }

            // --- Platform Collision (Vertical) ---
            this.player.onGround = false; this.player.groundPlatform = null; const currentY = this.player.y; const nextY = this.player.y + this.player.velocityY * dt;
            for (const platform of this.platforms) { if (this.player.x + this.player.width > platform.x && this.player.x < platform.x + platform.width) { if (this.player.velocityY >= 0 && currentY + this.player.height <= platform.y + 1 && nextY + this.player.height >= platform.y) { this.player.y = platform.y - this.player.height; this.player.velocityY = 0; this.player.onGround = true; this.player.groundPlatform = platform; this.player.coyoteTimer = 0; if (!wasOnGround) { this.player.landingTimer = 0.15; if (game && game.audioCtx) triggerLandSound(game.audioCtx.currentTime); } break; } if (this.player.velocityY < 0 && currentY >= platform.y + platform.height -1 && nextY <= platform.y + platform.height) { this.player.y = platform.y + platform.height; this.player.velocityY = 0; } } }

            // --- Coyote Timer Activation ---
            if (wasOnGround && !this.player.onGround) { this.player.coyoteTimer = COYOTE_TIME_DURATION; }

            // --- Update Position ---
            this.player.x += this.player.velocityX * dt;
            if (!this.player.onGround || this.player.velocityY < 0) {
                 this.player.y += this.player.velocityY * dt;
             }

            // --- Animation State Logic (Keep as is, focuses on movement/melee) ---
            let newState = 'idle';
            if (this.player.isAttacking) newState = 'attacking'; // Melee attack animation
            else if (this.player.landingTimer > 0) newState = 'landing';
            else if (!this.player.onGround && this.player.coyoteTimer <= 0) newState = 'jumping';
            else if (this.player.onGround && Math.abs(this.player.velocityX) > 0.1) newState = 'running';
            else if (this.player.onGround) newState = 'idle';

            if (this.player.animationState !== newState) { this.player.animationState = newState; this.player.animationTimer = 0; this.player.animationFrameIndex = 0; }

            // --- Animation Frame Update ---
            const animSpeedNorm = this.player.onGround ? GROUND_MAX_SPEED : AIR_MAX_SPEED;
            this.player.animationTimer += dt * animationSpeed * (this.player.animationState === 'running' ? Math.abs(this.player.velocityX / animSpeedNorm) : 1);
            const currentPoseArray = stickFigure.poses[this.player.animationState];
            if (currentPoseArray) { this.player.animationFrameIndex = Math.floor(this.player.animationTimer) % currentPoseArray.length; }
            else { this.player.animationFrameIndex = 0; if (this.player.animationState !== 'idle') console.warn("Missing pose for state:", this.player.animationState); }

            // --- Player Stardust Trail Emission ---
            const emitStardust = (holdingFlyInAir && Math.random() < STARDUST_EMIT_RATE * 1.5) || (!this.player.onGround && Math.abs(this.player.velocityY) > gravity * 5 && Math.random() < STARDUST_EMIT_RATE) || (this.player.onGround && Math.abs(this.player.velocityX) > GROUND_MAX_SPEED * 0.8 && Math.random() < STARDUST_EMIT_RATE);
            if (emitStardust) { const trailX = this.player.x + this.player.width / 2; const trailY = this.player.y + this.player.height; this.effectsSystem.emitPlayerTrail(trailX, trailY, this.player.velocityX, this.player.velocityY); }
         } // End updatePlayer


        // --- NEW: Handle Ranged Attack Trigger ---
        handleRangedAttack() {
            switch(this.player.selectedWeapon) {
                case 1: // Fireball
                    if (this.player.fireballCooldownTimer <= 0) {
                        this.spawnFireball(); // This will now use mouse aim
                        this.player.fireballCooldownTimer = FIREBALL_COOLDOWN;
                    }
                    break;
                case 2: // Lightning Bolt
                    if (this.player.lightningBoltCooldownTimer <= 0) {
                        this.castLightningBolt(); // Uses its own enemy-finding logic
                        this.player.lightningBoltCooldownTimer = LIGHTNING_BOLT_COOLDOWN;
                    }
                    break;
                case 3:
                    console.log("Attempted to fire Weapon 3 (Not Implemented)");
                    // Add logic and cooldown check for Weapon 3
                    break;
                case 4:
                    console.log("Attempted to fire Weapon 4 (Not Implemented)");
                    // Add logic and cooldown check for Weapon 4
                    break;
                case 5:
                    console.log("Attempted to fire Weapon 5 (Not Implemented)");
                    // Add logic and cooldown check for Weapon 5
                    break;
            }
        }


        // --- MODIFIED: Use Mouse Aim ---
        spawnFireball() {
            // Calculate player center in world coordinates
            const playerWorldX = this.player.x + this.player.width / 2;
            const playerWorldY = this.player.y + this.player.height / 2;

            // Get mouse position in world coordinates (requires cameraX)
            const mouseWorldX = this.game.mouseX + this.cameraX; // Use game's mouse pos + camera offset
            const mouseWorldY = this.game.mouseY; // Assuming cameraY is 0

            // Calculate angle from player to mouse
            const dx = mouseWorldX - playerWorldX;
            const dy = mouseWorldY - playerWorldY;
            const angle = Math.atan2(dy, dx);

            const fireball = { ...fireballProto };

            // Spawn slightly away from player center along the angle
            const spawnDist = this.player.width * 0.6;
            fireball.x = playerWorldX + Math.cos(angle) * spawnDist;
            fireball.y = playerWorldY + Math.sin(angle) * spawnDist;

            // Set velocity based on angle
            fireball.vx = FIREBALL_SPEED * Math.cos(angle);
            fireball.vy = FIREBALL_SPEED * Math.sin(angle); // Fireball can now move vertically
            fireball.active = true;
            fireball.life = FIREBALL_LIFESPAN; // Make sure life is set

            this.fireballs.push(fireball);

            if (game && game.audioCtx) {
                triggerFireballShoot(game.audioCtx.currentTime);
            }
        }

        // --- Chain Lightning Logic (Review: Seems okay, no changes needed based on prompt) ---
        castLightningBolt() { /* ... existing code ... */ }
        findClosestEnemyInRange(x, y, range, excludeTargets = []) { /* ... existing code ... */ }
        updateLightningBolts(deltaTime) { /* ... existing code ... */ }
        drawLightningBolt(bolt, ctx) { /* ... existing code ... */ }
        // --- End Chain Lightning ---


        render(ctx) {
            const time = this.game.currentTime;
            // Use the stored cameraX for rendering
            let cameraX = this.cameraX;
            let cameraY = 0; // Keep cameraY fixed for now

            // ** USE THE NEW BACKGROUND FUNCTION HERE **
            this.drawDesertDunesBackground(time * 1000, cameraX, ctx);

            this.drawLava(time * 1000, cameraX, ctx);
            ctx.save(); ctx.translate(-cameraX, -cameraY);

            // ... (rest of the drawing calls: platforms, collectibles, goal, enemies, etc.) ...

            // Make sure fireballs are drawn
            this.fireballs.forEach(fb => { if (fb.active) this.drawFireball(fb, ctx); }); // Ensure active check

            // Make sure lightning is drawn
            this.lightningBolts.forEach(bolt => this.drawLightningBolt(bolt, ctx));

            // ... (draw player, orbiters, effects) ...

            ctx.restore(); // Restore from camera translation

            // ... (draw screen flash, UI updates) ...
            this.updateTimerDisplay();
            this.updateLivesDisplay();
            this.updateOrbShieldDisplay();
            this.updateWeaponDisplay(); // Keep UI updated

            if (this.game.touchControls) this.game.touchControls.render(ctx);
            if (this.gameWon) { this.drawWinTextSimple(ctx); }
        }

        // ... (rest of GameplayScene methods: drawing helpers, updates for enemies, collisions, etc.)

        // --- MODIFIED: Pass cameraX ---
        drawFireball(fireball, ctx) {
            if (!fireball.active) return;

            ctx.save();

            // Calculate screen coordinates relative to camera
            const screenX = fireball.x; // Already in world coords
            const screenY = fireball.y;

            const gradient = ctx.createRadialGradient(
                screenX, screenY, 0,
                screenX, screenY, fireball.radius
            );
            // ... (gradient stops remain the same) ...
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
            gradient.addColorStop(0.3, 'rgba(255, 150, 50, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, fireball.radius, 0, Math.PI * 2);
            ctx.fill();

            // ... (glow and particle effects relative to screenX, screenY) ...
             ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
             ctx.shadowBlur = 15;
             ctx.beginPath();
             ctx.arc(screenX, screenY, fireball.radius * 0.7, 0, Math.PI * 2);
             ctx.fillStyle = 'rgba(255, 200, 50, 0.6)';
             ctx.fill();

            const particleCount = 3;
             for (let i = 0; i < particleCount; i++) {
                 const angle = Math.random() * Math.PI * 2;
                 const distance = Math.random() * fireball.radius * 0.5;
                 const particleX = screenX + Math.cos(angle) * distance;
                 const particleY = screenY + Math.sin(angle) * distance;
                 const particleSize = (Math.random() * 0.5 + 0.5) * fireball.radius * 0.3;

                 ctx.beginPath();
                 ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                 ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
                 ctx.fill();
             }

            ctx.restore();
        }

        updateFireballs(deltaTime) {
            for (let i = this.fireballs.length - 1; i >= 0; i--) {
                const fireball = this.fireballs[i];

                if (!fireball.active) {
                    // No need to remove here, let the check below handle it
                    continue;
                }

                // Update position (using vx, vy set during spawn)
                fireball.x += fireball.vx * deltaTime;
                fireball.y += fireball.vy * deltaTime;

                // Update lifetime
                fireball.life -= deltaTime;
                if (fireball.life <= 0) {
                    fireball.active = false; // Mark for removal / stop drawing
                    // Optional: Spawn minor explosion effect here even if no hit
                    this.effectsSystem.emitFireballExplosion(fireball.x, fireball.y, 5, '#aaaaaa');
                    continue; // Skip collision check if life ended
                }

                // Check for collisions with platforms (simple bounding box)
                let hitPlatform = false;
                for(const platform of this.platforms) {
                    if (fireball.x + fireball.radius > platform.x &&
                        fireball.x - fireball.radius < platform.x + platform.width &&
                        fireball.y + fireball.radius > platform.y &&
                        fireball.y - fireball.radius < platform.y + platform.height) {
                        hitPlatform = true;
                        break;
                    }
                }

                // Check for collisions with enemies or if it hit a platform
                if (hitPlatform || this.checkFireballEnemyCollisions(fireball)) {
                    fireball.active = false; // Deactivate on hit
                    // Trigger explosion effect and sound only on actual hit
                    this.effectsSystem.emitFireballExplosion(fireball.x, fireball.y);
                    if (game && game.audioCtx) triggerFireballExplode(game.audioCtx.currentTime);
                }
            }

             // Clean up inactive fireballs outside the loop
             this.fireballs = this.fireballs.filter(fb => fb.active || fb.life > -1); // Keep for a frame after inactive? Or just fb.active

        } // End updateFireballs


        // Renamed collision check function
        checkFireballEnemyCollisions(fireball) {
            const checkHit = (enemy) => {
                if (!enemy || enemy.health <= 0) return false;
                // More robust check: Circle (fireball) vs Rect (enemy)
                const closestX = Math.max(enemy.x, Math.min(fireball.x, enemy.x + enemy.width));
                const closestY = Math.max(enemy.y, Math.min(fireball.y, enemy.y + enemy.height));
                const dx = fireball.x - closestX;
                const dy = fireball.y - closestY;
                const distanceSquared = (dx * dx + dy * dy);
                return distanceSquared < (fireball.radius * fireball.radius);
            };

            for (const bat of this.bats) {
                if (checkHit(bat)) {
                    bat.health = 0; // Fireball insta-kills bats
                    this.effectsSystem.emitBatExplosion(bat.x + bat.width / 2, bat.y + bat.height / 2);
                    return true; // Stop checking after first hit
                }
            }
            for (const patroller of this.groundPatrollers) {
                 if (checkHit(patroller)) {
                     patroller.health -= 2; // Fireball does more damage
                     if (patroller.health <= 0) {
                         this.effectsSystem.emitBatExplosion(patroller.x + patroller.width / 2, patroller.y + patroller.height / 2, 10, PATROLLER_COLOR);
                         if (game && game.audioCtx) triggerPatrollerDestroy(game.audioCtx.currentTime);
                     } else {
                         this.effectsSystem.emitRewardSparkles(patroller.x + patroller.width / 2, patroller.y + patroller.height / 2, 5, '#ffccaa');
                         if (game && game.audioCtx) triggerPatrollerHit(game.audioCtx.currentTime);
                     }
                     return true;
                 }
             }
             for (const snake of this.snakes) {
                 if (checkHit(snake)) {
                     snake.health -= 1; // Example damage
                     if (snake.health <= 0) {
                         this.effectsSystem.emitBatExplosion(snake.x + snake.width / 2, snake.y + snake.height / 2, 10, SNAKE_COLOR);
                         // Add snake death sound?
                     } else {
                         this.effectsSystem.emitRewardSparkles(snake.x + snake.width / 2, snake.y + snake.height / 2, 5, '#ddbb55');
                         // Add snake hit sound?
                     }
                     return true;
                 }
             }
             if (this.boss && checkHit(this.boss)) {
                 this.boss.health -= 1; // Example damage
                 this.effectsSystem.emitRewardSparkles(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2, 10, GIANT_BAT_BOSS_COLOR_2);
                 // Add boss hit sound?
                 if (this.boss.health <= 0) {
                     this.boss.isDefeated = true; // Handle boss defeat logic
                     this.effectsSystem.emitBatExplosion(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2, 50, GIANT_BAT_BOSS_COLOR_1);
                 }
                 return true;
             }

            return false; // No enemy hit
        } // End checkFireballEnemyCollisions


        // Placeholder for Melee collision checks if needed separately
        checkMeleeAttackCollisions() {
             if (!this.player.isAttacking) return;

             // Calculate melee hitbox based on player facing direction
             const hitboxWidth = SWORD_HITBOX_WIDTH;
             const hitboxHeight = SWORD_HITBOX_HEIGHT;
             const hitboxY = this.player.y + this.player.height * 0.2;
             const hitboxX = (this.player.facingDirection === 'right')
                 ? this.player.x + this.player.width * 0.5 + SWORD_HITBOX_OFFSET_X
                 : this.player.x + this.player.width * 0.5 - SWORD_HITBOX_OFFSET_X - hitboxWidth;

             const attackRect = { x: hitboxX, y: hitboxY, width: hitboxWidth, height: hitboxHeight };

             // Check collisions with enemies using attackRect
             // Example for bats:
             this.bats.forEach(bat => {
                 if (bat.health > 0 && checkRectOverlap(attackRect, bat)) {
                     bat.health = 0; // Melee kills bats
                     this.effectsSystem.emitBatExplosion(bat.x + bat.width / 2, bat.y + bat.height / 2);
                     if (game && game.audioCtx) triggerSwordHit(game.audioCtx.currentTime); // Play hit sound

                     // Apply knockback (optional)
                     const knockbackDir = Math.sign(bat.x + bat.width/2 - (this.player.x + this.player.width/2));
                     bat.velocityX += knockbackDir * SWORD_KNOCKBACK_STRENGTH;
                     bat.velocityY += SWORD_VERTICAL_KNOCKBACK;
                 }
             });
             // Add similar checks for patrollers, snakes, boss...
              this.groundPatrollers.forEach(p => {
                  if (p.health > 0 && checkRectOverlap(attackRect, p)) {
                      p.health -= 1; // Melee damage
                      const knockbackDir = Math.sign(p.x + p.width/2 - (this.player.x + this.player.width/2));
                      p.velocityX += knockbackDir * SWORD_KNOCKBACK_STRENGTH * 0.5; // Less knockback?
                      if (p.health <= 0) {
                          this.effectsSystem.emitBatExplosion(p.x + p.width / 2, p.y + p.height / 2, 10, PATROLLER_COLOR);
                          if (game && game.audioCtx) triggerPatrollerDestroy(game.audioCtx.currentTime);
                      } else {
                          this.effectsSystem.emitRewardSparkles(p.x + p.width / 2, p.y + p.height / 2, 5, '#ffccaa');
                          if (game && game.audioCtx) triggerPatrollerHit(game.audioCtx.currentTime);
                      }
                      // Prevent multiple hits per swing maybe? Could add a flag to enemy `hitThisSwing = true`
                  }
              });
              this.snakes.forEach(s => {
                  if (s.health > 0 && checkRectOverlap(attackRect, s)) {
                       s.health -= 1; // Melee damage
                       const knockbackDir = Math.sign(s.x + s.width/2 - (this.player.x + this.player.width/2));
                       s.velocityX += knockbackDir * SWORD_KNOCKBACK_STRENGTH * 0.8; // Snake knockback?
                       if (s.health <= 0) {
                            this.effectsSystem.emitBatExplosion(s.x + s.width / 2, s.y + s.height / 2, 10, SNAKE_COLOR);
                       } else {
                            this.effectsSystem.emitRewardSparkles(s.x + s.width / 2, s.y + s.height / 2, 5, '#ddbb55');
                       }
                       if (game && game.audioCtx) triggerSwordHit(game.audioCtx.currentTime);
                  }
              });
               if (this.boss && this.boss.health > 0 && checkRectOverlap(attackRect, this.boss)) {
                   this.boss.health -= 1; // Melee damage
                    const knockbackDir = Math.sign(this.boss.x + this.boss.width/2 - (this.player.x + this.player.width/2));
                    this.boss.velocityX += knockbackDir * SWORD_KNOCKBACK_STRENGTH * GIANT_BAT_BOSS_KNOCKBACK_RESISTANCE; // Apply resistance
                    this.boss.velocityY += SWORD_VERTICAL_KNOCKBACK * GIANT_BAT_BOSS_KNOCKBACK_RESISTANCE;
                   this.effectsSystem.emitRewardSparkles(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2, 10, GIANT_BAT_BOSS_COLOR_2);
                   if (game && game.audioCtx) triggerSwordHit(game.audioCtx.currentTime);
                    if (this.boss.health <= 0) {
                        this.boss.isDefeated = true;
                        this.effectsSystem.emitBatExplosion(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2, 50, GIANT_BAT_BOSS_COLOR_1);
                    }
               }

        } // End checkMeleeAttackCollisions

    } // End GameplayScene Class

    

IGNORE_WHEN_COPYING_START
Use code with caution.JavaScript
IGNORE_WHEN_COPYING_END

5. Update Game Class (Minor):

Ensure the inputState.keys includes the new num1 to num5 properties if you haven't already initialized them flexibly.

      
class Game {
        constructor(canvas) {
            // ... other properties
            this.inputState = { keys: {
                left: false, right: false, up: false, w: false, space: false,
                r: false, m: false, x: false,
                num1: false, num2: false, num3: false, num4: false, num5: false // Add these
             } };
            // ... rest of constructor
            this.initInput(); // Called here
        }
        // ... rest of Game class
    }

    